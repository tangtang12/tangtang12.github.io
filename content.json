{"meta":{"title":"文艺青年","subtitle":"关注技术和人文的原创IT博客","description":"前端，博客，个人博客","author":"刘某某","url":"http://lsw.name"},"pages":[{"title":"为何建站 && 为何写作","date":"2017-02-07T05:23:07.000Z","updated":"2018-06-26T08:12:33.376Z","comments":false,"path":"about/index.html","permalink":"http://lsw.name/about/index.html","excerpt":"","text":"为何建站在我年轻的时候，独立站长曾是一个牛逼闪闪的角色，然而现在不那么神秘了。搭建说IT这个网站主要是为了记录技术成长的点滴，当然装逼也是一个目的。 为何写写作 读的书越多，你会发现知道的东西越多，不知道的东西就更多了，不知道远远大于知道，于是你在两者间不断碰撞、焦虑、欢喜、忧伤，产生各种思想、情感和故事，记录下来，就是文章。 引自《MacTalk》跨越边界 显然，写作是个艺术活儿，这个博客是带有某种程序员感情的，如果你是这种艺术家，那就能共震了！ 本站主要作为技术笔记存档，内容主要涉及前端开发（含移动端），偶尔可能也会有一些碎碎念、开开车。如果某一篇帮助了你，请记得点个赞。 作为内容站，持续输出高质量的内容是件不太容易的事情，本站的任何文章，你可任意转载，但请保留原文链接。如有兴趣，欢迎一起码字。 关于作者斜杠中年、文字控、周杰伦迷，就职于粗粮厂的90后程序猿。目前致力于JavaScript大法，ReactNative是目前的工作。鸡汤一站，请自取一篇饮 如果您遇到麻烦或对本站有疑问，请在本站找到那个白色❓号并点击查看 没时间再解释了，赶紧上车…"},{"title":"嘉宾推荐","date":"2017-02-07T05:22:22.000Z","updated":"2018-06-26T15:40:22.628Z","comments":false,"path":"links/index.html","permalink":"http://lsw.name/links/index.html","excerpt":"","text":"以下摘录有趣、有意义、有影响力、有正能量的博客、资源 此处不做网址导航，因此不接受以SEO为目的的友链。排序不分那啥… JS大法系 阮一峰博客闲情写手腾讯AlloyTeam 苹果派 王巍（喵神）的博客Objc.ioSwifter 娱乐圈 VIMCodeTank 公众号 没有链接，请直接关注微信公众号：涔汐(zhangcenxi99)、小道消息、MacTalk等等"},{"title":"移动互联网？","date":"2017-03-18T11:56:20.000Z","updated":"2018-06-26T15:39:02.575Z","comments":false,"path":"app/index.html","permalink":"http://lsw.name/app/index.html","excerpt":"","text":"憋闹了，还没App。网页写的差不多了，再考虑写移动互联网….public static void main(String args[]) throws Exception &#123; for (int i = 0; ; i++) &#123; Thread.sleep(1000); System.out.println(\"嗯、写码，呵呵...\" + i); &#125;&#125; fyiguhjnwkefnmwoeih68yuih4jnkrfewdfyugbijnk.wfww3f 5jhyrtgve5jhytbgvef5grefvqwu6ejynhbvwer5jr5hb4gevgwh54uh3g4weab eh43eg223t4whretbvfw345u36jhtbevww32q4wu5ejhtbevwgw354uhtbgevfcewg 擦了下键盘，这些你可以拿去当QQ密码，绝不会被盗号，不用谢！"},{"title":"QA - 帮助那个中心...","date":"2017-03-29T10:49:38.000Z","updated":"2018-06-26T15:39:51.509Z","comments":true,"path":"help/index.html","permalink":"http://lsw.name/help/index.html","excerpt":"","text":"这里不发表情，准备说点严肃、实在的…Q: 这网站怎么弄的，还挺好看的啊？ A: 本站是静态博客，通过hexo生成，主题是我自己写的。免费使用，已开源至GitHub，本站底部有它们的链接 Q: 为什么博客有时候打开速度很慢，一直在加载呢？ A: 评论组件使用的Disqus等资源的服务器在墙外，你懂的…(不懂问搜狗)。不过不影响文章阅读。 Q: 我也想用这个主题搭个博客，不知道怎么弄？ A: 先去hexo官网看看，学会用这个写作并学会使用gitpages之类的部署博客。教程谷歌一下遍地皆是。主题是免费的，在本站底部可找到链接，根据文档自及配置就好了。遇到问题，在本页留言即可，我会很愿意帮助你的。需要注意的是主题有全站https开关，在主题_config.yml文件的fullHttps处配置。如配置不当r某些文件就无法正确引用，加载粗来的页面会很挫。 Q: 你这主题，我配置了怎么运行报错啊，跑不起来啊？ A: 关于使用主题出错，请先前往JSimple-issues寻找答案，说不定你遇到的问题，已经有人碰到而我也回答解决方式了。关于主题的任何问题，我都会在那里回复 Q: 无法自由翱翔互联网咋办？ A: 着急吃饭且自甘有钱的朋友请直接购买蓝灯。不着急就慢慢找吧，像GreenVPN、www.ishadowsocks.com都是很好的方案。另外有hosts方案，请前往这个项目UsefullShells Q: 如何找到一个靠谱的对象？ 如果你有资源，记得第一时间告诉我… Q: 我觉得站长你挺有意思的，能交个朋友吗？ A: 可以，来握个手吧：斜杠中年 暂时更新这些，需要什么本文底部留言……"},{"title":"标签云","date":"2017-02-04T07:37:12.000Z","updated":"2018-06-26T15:40:40.790Z","comments":true,"path":"tags/index.html","permalink":"http://lsw.name/tags/index.html","excerpt":"","text":""},{"title":"时光轴","date":"2017-02-07T05:23:27.000Z","updated":"2018-06-26T15:41:00.720Z","comments":false,"path":"timeline/index.html","permalink":"http://lsw.name/timeline/index.html","excerpt":"","text":"时光轴嘛，得先有时光，会更新的，别急……"}],"posts":[{"title":"虚拟DOM","slug":"虚拟dom","date":"2017-08-10T13:18:28.000Z","updated":"2018-07-14T02:29:58.105Z","comments":true,"path":"front-end//1502371108.html","link":"","permalink":"http://lsw.name/front-end/1502371108.html","excerpt":"","text":"DOM创建的流程 所有的浏览器的引擎工作流程都差不多，如上图大致分5步： 创建DOM tree 用HTML分析器，分析HTML元素构建一颗DOM树 创建Style Rules 样式规则 用css分析器，分析CSS文件和元素上的inline样式，生成页面的样式表 构建Render tree 将上面的DOM树和样式表，关联起来，构建一颗Render树。这一过程又称为Attachment，这个DOM节点都有attach方法，接受样式信息，返回一个render对象(又称为renderer)。这些render对象最终会构建一颗render树 布局Layout 有了Render树后，浏览器开始布局，会为每个Render树上的节点确定一个显示屏上出现的精确坐标值 绘制Painting Render树有了，节点显示的位置坐标也有了，最后就是调用每个节点的paint方法，让他们显示出来 为什么出现虚拟DOM 当你用传统的原生API或者JQ去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程，会引发回流和重绘。在V8引擎中，可以将操作DOM放在一块执行，可以减少回流和重绘(优化方案) 即使计算机硬件一直在更新迭代，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验。真实的DOM节点，哪怕一个简单的DIV也包含着很多属性(window.getComputedStyle查看元素的属性) 虚拟DOM就是为了解决这个浏览器性能问题而被设计出来的。假如一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM。而是将这10次更新的diff内容保存到本地的一个JS对象中，最终将这个JS对象一次性attach到DOM树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量 实现一个虚拟DOM 真实的DOM&lt;div id=\"real-container\"&gt; &lt;p&gt;Real Dom&lt;/p&gt; &lt;div&gt;xxx&lt;/div&gt; &lt;ul&gt; &lt;li class=\"item\"&gt;item1&lt;/li&gt; &lt;li class=\"item\"&gt;item2&lt;/li&gt; &lt;li class=\"item\"&gt;item3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 虚拟DOMconst tree =Element('div',&#123;id:\"container\"&#125;, [ Element('p',&#123;&#125;,['DOM']), Element('div',&#123;&#125;,['xxx']), Element('ul',&#123;&#125;,[ Element('li',&#123;class:\"item\"&#125;,['item1']), Element('li',&#123;class:\"item\"&#125;,['item2']), Element('li',&#123;class:\"item\"&#125;,['item3']), ]), ]) react是JSX语法，通过babel转义为类似的虚拟DOM Diff 算法 我们已经完成了创建虚拟DOM并将其映射成真实DOM的工作，这样所有的更新都可以先反映到DOM上。 有大致4中情况 节点类型的改变，如上上述的p变为h3，将整个过程称之为replace，直接将旧节点卸载并装载新节点就行 仅仅是属性或者属性值变了，将这个过程称之为PROPS，执行节点更新的一系列方法(生命周期)-文本变了，文本对也是一个Text Node，也比较简单，直接修改文字内容就行，这个过程为TEXT 移动、增加、删除子节点，这个过程称之为peorder。","categories":[{"name":"前端","slug":"front-end","permalink":"http://lsw.name/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"}]},{"title":"React的路由","slug":"react的路由","date":"2017-07-15T13:18:28.000Z","updated":"2018-07-14T02:29:58.175Z","comments":true,"path":"front-end//1500124708.html","link":"","permalink":"http://lsw.name/front-end/1500124708.html","excerpt":"","text":"react的路由使用 react 路由 学习 react 路由[http://reacttraining.cn/web/api/] 1.安装 yarn-add react-router-dom———-3及以前版本称为react-router———-4及最近版本称为react-router-dom 常用的方法 2.BrowserRouter vs HashRouter 它是两种常用的路由实现思想，BrowserRouter 浏览器路由，HashRouter 哈希路由[BrowserRouter]它是基于 H5 中的 history API(pushState,replaceState,popState)来保持 UI 和 URL 同步，真实项目中应用的不多，一般只有当前项目是基于服务器渲染的才会使用浏览器路由http://www.demo.com/http://www.demo.com/personalhttp://www.demo.com/personal/login[HashRouter]真实项目中(前后端分离的项目:客户端渲染)我们经常使用的哈希路由来完成的，他依据相同的页面地址，不同的哈希值，来规划当前页面中的那一个组件呈现渲染，他基于原生 JS 构造了一套类似于 history API 的机制，每一次路由的切换都是基于 history stack 完成的http://www.demo.com/#/http://www.demo.com/#/personalhttp://www.demo.com/#/personal/login HashRouter 1.当前项目一旦使用了 HashRouter，则默认在页面的地址后面加上”#/“,也就是 HASH 默认值是一个斜杠，我们一般让其显示首页组件信息内容 2.HashRouter 中只能出现一个子元素 3.HashRouter 机制中，我们需要根据哈希地址不同，展示不同的组件内容，此时需要使用 route Route path 设置匹配哈希值后面的值(地址)，但是默认不是严格匹配，当前页面哈希地址只要包含完整的它(内容是不变的)，都能被匹配上 path=’/‘ 和它匹配的地址只要有斜杠即可(都能和它匹配) path=’/user’:”#/user/login”也可以匹配，但是”#/user2”这个无法匹配 在Route加上属性exact，可以使其path严谨匹配(只有url的哈希值和path设定的值相等才可以匹配到) path=”/A” “#/A”可以被匹配 “#/“不可以匹配 在Route加上属性static，可以使其严格匹配 path=”/A/“ path=”/A/“匹配 path=”/A”不匹配 path=”/A/B”匹配 属性render：当页面的哈希地址和path匹配，会把render规划的方法执行，在方法中一般做”权限校验” (渲染组件之前验证是否存在权限，不存在做一些特殊处理) component 一旦哈希值和当前 Route 的 path 相同了，则渲染 component 指定的组件 默认情况下，会和每一个 route 都做校验(哪怕之前已经有校验成功的),switch 组件可以解决这个问题，和 Switch Case 一样，只要有 一种情况校验成功，就不在向后检验了import React from 'react';import ReactDOM,&#123;render&#125; from 'react-dom';// noinspection ES6CheckImportimport &#123;HashRouter,Route,Switch,Redirect&#125; from 'react-router-dom';import A from \"./hash/A\";import B from \"./hash/B\";import C from \"./hash/C\";render(&lt;HashRouter&gt;&lt;Switch&gt;&lt;Route path='/' component=&#123;C&#125; exact /&gt;&lt;Route path='/A' component=&#123;A&#125; /&gt;&lt;Route path='/pay' component=&#123;B&#125; /&gt;&lt;Route path='/pay1' render=&#123;()=&gt;&#123;//一般在 render 中处理的是权限校验let flag=localStorage.getItem('FLAG');if (flag&amp;&amp;flag==='SAFE')&#123;return &lt;C/&gt;;&#125;return '当前环境不安全，不利于支付'&#125;&#125; /&gt; &#123;/*上述都设置完成后，会在末尾设置一个匹配，以上都不符合的情况下，我们认为路由地址是非法的地址，我们做一些特殊处理，肉Route中path不写,就是匹配所有地址规则*/&#125; &#123;/*&lt;Route render=&#123;()=&gt;&lt;div&gt;404&lt;/div&gt;&#125; /&gt;*/&#125; &#123;/*也可以基于redirect 重定向到哪 to [string]重新定向到新的地址后的组件 to [OBJECT]重新定向到新的地址，只不过指定了更多的信息 &#123;PATHNAME:定向的地址,search:给定向的地址问号传参(结合当前案例，真实项目中，我们有时候会根据是否存在问号参数值来统计是正常进入首页还是非正常跳转过来的，也有可能根据问号传参值做不同的事情),state:给定向后的组件传递一些信息&#125; push 如果设置了这个属性，当前跳转的地址，会加入到history stack中一条记录 from 设置当前来源的页面地址 &lt;Redirect from='/custom' to='/custom/list' /&gt;如果当前请求的HASH地址是\"/custom\"，我们让其重定向到/custom/list */&#125; &#123;/*&lt;Redirect to='/?lx=404' /&gt;*/&#125; &lt;Redirect to=&#123;&#123;pathname:'/',search:'?lx=404'&#125;&#125; /&gt; &lt;/Switch&gt;&lt;/HashRouter&gt;,root);","categories":[{"name":"前端","slug":"front-end","permalink":"http://lsw.name/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://lsw.name/tags/React/"}]},{"title":"React 的生命函数","slug":"react的生命函数","date":"2017-07-11T13:45:23.000Z","updated":"2018-07-11T14:33:51.786Z","comments":true,"path":"product-design//1499780723.html","link":"","permalink":"http://lsw.name/product-design/1499780723.html","excerpt":"","text":"React生命周期函数(钩子函数) 描述一个组件或者程序从创建到销毁的过程，我们可以在过程中间基于钩子函数完成一些自己的操作(例如：在第一次渲染完成做什么，或者第二次即将重新渲染之前做什么等…) [基本流程] constructor 创建一个组件 componentWillMount 第一次渲染之前 render 第一次渲染 componentDidMount 第一次渲染之后 [修改流程:当组件的状态数据发生改变(setState)或者传递给组件的属性发生改变(重新调用组件传递不同的属性)都会引发 render 重新执行渲染(渲染也是差异渲染)] shouldComponentUpdate 是否允许组件重新渲染(允许则执行后面函数，不允许直接结束即可) componentWillUpdate 重新渲染之前 render 第二次及以后重新渲染 componentDidUpdate 重新渲染之后 componentWillReceiveProps 父组件把传递给子组件的属性发生改变后触发的钩子函数 [卸载:原有的渲染的内容是不消失的，只不过以后不能基于数据改变视图了] componentWillUnmount 卸载组件之前(一般不用)","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://lsw.name/tags/React/"}]},{"title":"React 的组件","slug":"react的组件","date":"2017-07-05T13:05:33.000Z","updated":"2018-07-11T14:45:48.391Z","comments":true,"path":"product-design//1499259933.html","link":"","permalink":"http://lsw.name/product-design/1499259933.html","excerpt":"","text":"ReactReact 组件 不管是 vue 还是 react 组件，设计之初都是期望我们按照”组件/模块管理”的方式来构建程序的，也就是把一个程序划分为一个个的组件来单独管理优势 有助于多人协作开发 我们开发的组件可以被复用 react 创建组件有两种方式; src-&gt;component这个文件件中存放的是开发组件 函数声明式文件 必须导入 react 模块(import),需要用到 JSX 的语法 函数返回的结果是一个新的 JSX(也就是当前组件的结构) props 变量存储的的值是一个对象，包含了调取组件时候传递的属性值,不传递的时候是一个空对象 基于继承 Component 类来创建组件 基于 createElement 把 JSX 转换为一个对象，当 render 渲染这个对象的时候，遇到 type 是一个函数或者类，不是直接创建元素，而是先把方法执行： 如果就是函数式声明的组件，就把它当做普通函数执行(方法中的 this 是 undefined)，把函数返回的 JSX 元素(也就是解析后的对象)进行渲染 如果是类声明式组件，会把当前类 new 执行，创建类的一个实例(当前本次调取的组件就是他的实例)，执行 constructor 之后，会执行 this.render(),把 render 中返回的 JSX 拿过来进行渲染，所以类声明式组件，必须有一个 render 的方法，方法中返回一个 JSX 元素 但是不管是那一种方式，最后都会把解析出来的 props 属性对象作为实参传递给对应的函数或者类 总结： 创建组件有两种方式 “函数式” “创建类式” [函数式] 写起来简单，操作简单 功能也是比较单一，只是简单的调取和返回 JSX 而已 [创建类式] 操作相对复杂一些，但是也可以实现更为复杂的业务功能 能够使用生命周期函数操作业务 函数式可以理解为静态组件(组件中的内容调取的时候就已经固定了，很难在修改)，而类这种方式，可以基于组件内部的状态来动态更新渲染的内容 组件的重要概念、开发的核心思想React 中的组件有两个非常重要的概念 组件的属性:[只读]调取组件的时候传递进来的信息 组件的状态:[读写]自己在组件中设定和规划的(只有类声明式组件才有状态的管控，函数组件声明不存在状态的管理) 组件状态类似于 VUE 中的数据驱动:我们数据绑定的时候是基于状态值绑定，当修改组件内部状态后，对应的 JSX 元素也会跟着重新渲染(差异渲染:只把数据改变的部分重新渲染，基于 DOM-DIFF 算法完成的) 当代前端框架最重要的核心思想就是:”数据操作视图(视图影响数据)”,告别 JQ 时代，我们以后只需要改变数据，框架会帮我们重新渲染视图，从而直接减少操作 DOM(提高性能，也有助于开发效率) 受控组件和非受控组件 真实项目中，建议大家多使用受控组件 基于数据驱动(修改状态数据，react 帮助我们重新渲染视图)完成的组件叫做”受控组件(受数据控制的组件)” 基于 ref 操作 DOM 实现视图更新的，叫做”非受控组件” 组件嵌套1.复合组件:父组件嵌套子组件 [传递信息的方式] 父组件需要把信息传递给子组件 [属性传递]：调取子组件的时候，把信息基于属性的方式传递给子组件(子组件 props 中存储传递的信息);这种方式只能父组件把信息传递给子组件，子组件无法直接的吧信息传递给父组件，也就是属性传递信息是单向传递的 &lt;section className=\"panel panel-default\"&gt; &lt;VoteHead title=&#123;title&#125; /&gt;&lt;/section&gt; [上下文传递父组件先把需要给后代元素(包括孙子元素)使用的信息都设置好(设置在上下文中)，后代组件需要用到父组件中的信息，主动去父组件中调取使用即可 harmony//父组件中 static childContextTypes=&#123; //设置上下文中的信息值的类型 n:PropTypes.number, m:PropTypes.number, &#125;; getChildContext()&#123; //return的是啥，相当于给上下文设置的是啥 return&#123; n:this.props.count.n, m:this.props.count.m, &#125; &#125;//子组件 static contextTypes=&#123; //首先类型需要和设置时候一样，用啥就写啥 n:PropTypes.number, m:PropTypes.number &#125;; 属性 VS 上下文 属性操作起来比较简单，子组件是被动接受传递的值 (组件内的属性是只读的，只能父传子，子传父或者父直接传孙都是不行的，父传孙需要处理，父传子，子传孙) 上下文操作起来相对比较复杂一些，子组件是主动获取信息的(子组件是可以修改获取到的上下文信息的，但是不会影响父组件中的信息，其他组件是不受影响的)，一旦父组件设置了上下文信息，他后代组件都可以直接拿来使用不需要一层层的传递; 子组件修改父组件中的信息 利用回调函数的机制：父组件把一个函数通过属性或者上下文的方式，传递给子组件，子组件只要把这个方法执行即可(也就是子组件中执行父组件中的方法，还可以传递一些值过去)，这样父组件在这个方法中，想把自己的信息改成啥就改成啥 平行组件:兄弟组件或者毫无关系的两个组件 让二个平行组件拥一个共同的父组件 父： parent 子： A/B 父组件中有一些信息，父组件把一个方法传递给 A，A 中把方法执行(方法执行修改父组件信息值)，父组件再把最新的信息传递给 B 即可，等价于 A 操作，影响了 B 基于 redux 来进行状态管理，实现组件之间的信息传输(常用方案) redux 可以应用在任何的项目中(vue/jq/react 的都可以)，react-redux 才是 react 项目专用的方案","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://lsw.name/tags/React/"}]},{"title":"React 的 MVC 模式、脚手架以及把 JSX 渲染为真实的 DOM 原理","slug":"react的MVC模式、脚手架以及把JSX渲染为真实的DOM原理","date":"2017-07-01T14:14:28.000Z","updated":"2018-07-11T14:56:52.009Z","comments":true,"path":"product-design//1498918468.html","link":"","permalink":"http://lsw.name/product-design/1498918468.html","excerpt":"","text":"React简述 MVC 框架 MVC 是一种使用 MVC(Model View Controller 模型-视图-控制器)设计创建 Web 应用程序的模式 Model(模型)可以简单的理解为数据层，用于提供数据。对数据库的操作这一些的代码作为 model 层， View(视图)是应用程序中处理数据显示的部分，通常视图是依据模型数据创建的，一般所有的 JSP、HTMl 等页面就是 View 层 Controller(控制器)功能就是将 Model 和 View 层进行关联，比如 View 主要是显示数据的，但是数据又需要 Model 去访问，这样的话，View 会先告诉 Controller，然后 Controller 再告诉 Model，Model 请求完数据之后，再告诉 View。这样 View 就可以显示数据了 React 脚手架 前端的工程化开发 划分组件开发 基于路由的 SPA 单页面开发 一般都是基于 ES6 来编写代码(最后部署上线的时候，我们需要把 ES6 编译为 ES5=&gt;基于 babel 来完成编译) 可能用到 Less/Sass 等，我们也需要对应的插件把他们进行预编译 最后为了优化性能，减少 http 请求的次数，我们需要把 js/css 进行合并压缩 webpack 来完成以上页面组件合并、js/css 编译加合并等工作 创建脚手架 安装create-react-app npm install create-react-app -g 基于create-react-app [项目名称]脚手架的命令，创建一个基于 react 的自动化/工程化项目目录，项目名称中不能出现大写字母、中文汉字，特殊符号(-或者_是可以)等 脚手架生成目录中的一些内容 node_modules 当前项目中依赖的包都安装在这里(.bin 本地项目中可执行的命令，在 package.json 的 scripts 中配置对应的脚本命令) public 存放的是当前项目的 HTML 页面(单页面应用放一个 index.html 即可，多页面根据自己需求放置需要的页面) src 项目结构中主要的目录，因为后期所有的 JS、路由、组件都是放到这里面(包括需要编写的 css 或者图片等)，index.js 是当前项目的主入口文件 .gitignoregit 提交时候，忽略提交文件的配置项 package.json 当前项目的配置清单,基于脚手架生成工程目录，自动帮我们安装了三个模块:react/react-dom/react-scripts,react-scripts 集成了 webpack 需要的内容(编译包：babel 一套，css 处理的一套，eslint 一套，webpack 一套，其他的，没有 less/sass 的处理内容，项目中若是使用 less，我们需要自己额外的安装) //package.json&#123; \"dependencies\": &#123; \"react\": \"^16.4.1\", \"react-dom\": \"^16.4.1\", \"react-scripts\": \"1.1.4\" &#125;, \"scripts\": &#123; \"start\": \"react-scripts start\" /*开发环镜下，基于webpack编译处理，最后可以预览当前开发的项目成果(在webpack中安装了webpack-dev-server插件，基于这个插件会自动创建一个web服务[端口号默认是3000]，webpack会默认打开浏览器，并展示我们的页面，并且能够监听我们代码的改变，如果代码改变，webpack会自动重新编译，并且刷新浏览器完成重新渲染)*/, \"build\": \"react-scripts build\" /*项目需要部署到服务器上，我们先执行yarn build，把项目整体编译打包 (完成后会在项目中生成一个build文件夹，这个文件夹中包含了所有编译后的内容，我们把它上传到服务器即可),而且在服务上进行部署的时候，不需要安装任意的模块*/, \"test\": \"react-scripts test --env=jsdom\", \"eject\": \"react-scripts eject\" &#125;&#125; public 中路径的问题&lt;link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\"&gt;&lt;link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\"&gt; 在 react 当中，所有的逻辑都是在 jS 中完成的(包括页面结构的创建)，如果想给当前页面导入一些 css 样式或者 img 图片等内容，我们有两种方式， 第一种在 JS 中基于 es6 module 模块规范，使用 import 导入，这样 webpack 在编译合并 JS 的时候，会把导入的资源文件等插入到页面的结构中(绝对不能在 js 管控的结构中通过相对目录./或者../,导入资源) ，因为 webpack 编译的时候，地址就不在是 之前的相对路径 第二种，如果不想在 js 中导入(JS 中导入的资源最后都会基于 webpack 编译，我们也可以把资源手动的在 HTML 中导入，但是 HTML 最后 也要基于 webpack 编译，导入的地址也不建议写相对地址，而是使用%public_URL%写成绝对地址) 脚手架的深入 create-react-app 脚手架为了结构目录清晰，把安装的 webpack 及配置文件都集成在了 react-scripts 模块上，放到了 node_modules 中 真实项目中，我们需要在脚手架默认安装的基础上，额外安装一些我们需要的模块，例如：react-router-dom/axios/…,再比如 less/less-loader… 情况一：如果我们安装其他的组件，但是安装成功后不需要修改 webpack 的配置项，此时我们直接安装，并且调取使用即可 情况二：我们安装的插件是基于 webpack 处理的，也就是需要把安装的模块配置到 webpack 中，需要重新修改 webpack 配置项了： 首先需要把隐藏到 node_modules 的配置项暴露到项目中yarn eject,首先会提示确认是否执行 eject 操作，这个操作是不可逆的，一旦暴露出来配置项，就无法隐藏回去了，如果当前的项目基于 git 管理，会报错，提醒你提交到历史区 再去修改对应的配置项即可，一旦暴露后，项目目录中多了两个文件夹：config 存放的是 webpack 的配置文件(webpack.config.dev.js 开发环镜下的配置项-yarn start，webpack.config.prod.js 生产环镜下的配置项-yarn build)，scripts 存放的是可执行脚本的 js 文件(start.js/build.js/test.js=&gt;yarn xxx 对应) package.json 也改变了， 例如 less less 是开发和生产环镜下都需要配置的 我们预览项目的时候，也是基于 webpack 编译，把编译后的内容放到浏览中运行，所以如果项目中使用了 less，我们需要修改 webpack 配置项，在配置项中放入 less 的编译工作，这样后期预览项目，首先基于 webpack 编译成 css，再呈放到页面中 环镜变量的修改、协议、端口号 set HTTPS=true&amp;&amp;yarn start 开启 HTTPS 协议 设置环镜变量 HTTPS 的值 set PORT=63341&amp;&amp;yarn start 修改端口 react&amp;&amp;react-dom [渐进式框架] 目前最流行的框架设计思想，一般框架中包含很多内容，这样导致框架的体积过于臃肿，不利于页面的优化，真实项目中，我们使用一个框架，不一定用到所有的功能，此时我们应该把框架的功能拆分，用户想用什么，让其自己自由组合即可 [全家桶] 渐进式框架 N 多部分的组合 vue 全家桶:vue-cli/vue/vue-router/vuex/axios(fetch)/vue element(vant) react 全家桶:creatr-react-app/react/react-dom/react-router/redux/react-redux/axios/ant/dva/saga/mobx react:react 框架的核心部分，提供了 Component 类可以供我们进行组件开发，提供了钩子函数(生命周期函数:所有的生命周期函数都是基于回调函数完成的)react-dom:把 jsx 语法(react 独有的语法)渲染为真实的 DOM(能够放到页面中展示的结构都叫做真实的 DOM)的组件 把 JSX(虚拟 DOM)变为真实的 DOM//导入组件import React from 'react';import ReactDOM from 'react-dom';//语法ReactDOM.render([jsx],[container],[callback]);把jsx元素渲染到页面中 jsx：react虚拟元素 container容器，我们想把元素放到页面中的哪个容器中 callback：当把内容放到页面中呈现触发的回调函数 JSX：react 独有的语法 javascript+XML(HTML) 和我们之前自己拼接的 HTML 字符串类似，都是把 HTML 结构代码和 JS 代码或者数据混合在一起了，但是他不是字符串 在写 render 的时候的规范 1.不建议我们把 jsx 直接渲染到 body 中，而是放在自己创建一个容器中，一般我们都放在一个 ID 为 root 的 DIV 中即可*/ 2.在 JSX 中出现的{}是存放 js 的，但是要求 js 代码执行完成需要有返回结果(JS 表达式) - 不能直接放一个对象数据类型的值(对象(除了给style赋值)、数组(数组中没有对象都是基本值或者是JSX元素，这样是可以的)、函数都不行) - 可以是基本类型的值(布尔类型的值什么都不显示，但是不会报错，null、undefined也是JSX元素，代表是空) - 循环判断的语句 都不支持，但是支持三元运算符 3.循环数组创建 JSX 元素(一般都是基于数组的 MAP 方法完成迭代)，需要给创建的元素设置唯一的 key 值(当前本次循环内唯一即可) 4.只能出现一个根元素 5.给元素设置样式类用的是 className 不是 class6.style 中不能直接写样式字符串，需要基于一个样式对象来遍历赋值jsx 渲染机制 1.基于 babel 中的语法解析模块(babel-preset-react)把 jsx 语法编译为 React.createElement(…)的结构 2.执行 React.createElement(type,props,children)函数，会创建一个对象(虚拟 DOM)3.ReactDOM.render(JSX 语法最后生成的对象，容器，回调函数)，基于 Render 方法把生成的对象动态创建为 DOM 元素，插入到指定的容器中 JS 原理 //参数至少两个，type/props children这个部分可能没有可能有多个function createElement(type, props, ...childrens) &#123; //返回一个对象，创建一个对象，默认有四个属性(type,props,ref,key) //根据传递的值修改这个对象 /* * type 传递的type的值 * props 需要做一些处理:大部分传递的props属性都赋值给对象的props，有一些比较特殊 如果是ref或者key，我们需要把传递的props的这两个属性值删除掉 * 把传递的children作为新创建对象的props中的一个属性*/ props = props || &#123;&#125;; let obj = &#123; type: \"null\", props: &#123; children: \"\" &#125;, ref: null, key: null &#125;; //obj=&#123;...obj,type,props&#125;;//=&gt;&#123;type:type,props:props&#125;用传递的type和props覆盖原有的默认值 obj = &#123; ...obj, type, props: &#123; ...props, children: childrens.length &lt;= 1 ? childrens[0] || \"\" : childrens &#125; &#125;; //=&gt;把ref和key都提取出来,并且删除props中的属性 \"key\" in obj.props ? ((obj.key = obj.props.key), delete obj.props.key) : null; \"ref\" in obj.props ? ((obj.ref = obj.props.ref), (obj.props.ref = undefined)) : null; return obj;&#125;/*Render把创建的元素生成对象的DOM元素，最后插入到页面中*/function render(obj, container, callback) &#123; let &#123; type, props &#125; = obj || &#123;&#125;, newElement = document.createElement(type); for (let attr in props) &#123; if (!props.hasOwnProperty(attr)) break; //结束遍历 if (!props[attr]) continue; //继续下一个 let value = props[attr]; if (attr === \"className\") &#123; newElement.setAttribute(\"class\", value); continue; &#125; if (attr === \"style\") &#123; if (value === \"\") continue; for (let styKey in value) &#123; if (value.hasOwnProperty(styKey)) &#123; newElement.style[styKey] = value[styKey]; &#125; &#125; continue; &#125; if (attr === \"children\") &#123; /*可能是一个值:是字符串成也可能是JSX对象 或者数组 数组中的每一项可能是字符串也可能是JSX对象*/ if (!(value instanceof Array)) &#123; value = [value]; //统一变成数组方便操作 &#125; value.forEach((item, index) =&gt; &#123; //验证item是什么类型的 字符串就是创建文本节点，是对象，再次执行render方法，把创建的元素放到做开始的大盒子中 if (typeof item === \"string\") &#123; let text = document.createTextNode(item); newElement.appendChild(text); &#125; else &#123; render(item, newElement); &#125; &#125;); continue; &#125; newElement.setAttribute(attr, value); //基于setAttribute可以使设置的属性表现在HTML上 &#125; container.appendChild(newElement); callback &amp;&amp; callback();&#125;//方法的使用let obj = createElement( \"div\", &#123; id: \"box\", className: \"box\", style: &#123; color: \"red\" &#125; &#125;, createElement(\"h2\", &#123; className: \"title\" &#125;, \"\\u7CFB\\u7EDF\\u63D0\\u793A\"), createElement( \"div\", &#123; className: \"content\" &#125;, \"\\u6E29\\u99A8\\u63D0\\u793A\\uFF1A\\u8BED\\u6CD5\\u9519\\u8BEF\\uFF01\" ), \"\\u672C\\u64CD\\u4F5C\\u5C31\\u662F\\u4E00\\u4E2A\\u6D4B\\u8BD5\\uFF01\");render(obj, root, () =&gt; &#123; console.log(\"ok\");&#125;);","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://lsw.name/tags/React/"}]},{"title":"Promise 原理","slug":"promise原理","date":"2017-06-10T13:18:28.000Z","updated":"2018-07-11T14:47:09.337Z","comments":true,"path":"front-end//1497100708.html","link":"","permalink":"http://lsw.name/front-end/1497100708.html","excerpt":"","text":"Promiseclass Promise &#123; constructor(fn) &#123; this.value = undefined; this.state = \"pending\"; this.resolveAry = []; this.rejectAry = []; let resolveFn = res =&gt; &#123; let timer = setTimeout(() =&gt; &#123; clearTimeout(timer); if (this.state === \"pending\") return; this.state = \"success\"; this.resolveAry.forEach(item =&gt; &#123; item(this.value); &#125;); &#125;); &#125;; let rejectFn = err =&gt; &#123; let timer = setTimeout(() =&gt; &#123; clearTimeout(timer); if (this.state === \"pending\") return; this.state = \"failed\"; this.rejectAry.forEach(item =&gt; &#123; item(this.value); &#125;); &#125;); &#125;; fn(resolveFn, rejectFn); &#125; then(resolveCallback, rejectCallback) &#123; typeof resolveCallback !== \"function\" ? (resolveCallback = res =&gt; res) : null; typeof rejectCallback !== \"function\" ? (rejectCallback = err =&gt; &#123; throw new Error(err instanceof \"Error\" ? err.message : err); &#125;) : null; return new Promise((resolve, reject) =&gt; &#123; this.resolveAry.push(() =&gt; &#123; try &#123; let x = resolveCallback(this.value); x instanceof Promise ? Promise.then(resolve, reject) : resolve(x); &#125; catch (e) &#123; reject(e); &#125; &#125;); this.rejectAry.push(() =&gt; &#123; try &#123; let x = rejectCallback(this.value); x instanceof Promise ? Promise.then(resolve, reject) : resolve(x); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; catch(reject) &#123; this.then(null, reject); &#125; static all(promiseAry = []) &#123; let index = 0, result = []; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promiseAry.length; i++) &#123; promiseAry[i].then(res =&gt; &#123; index++; result[i] = res; if (index === promiseAry.length) &#123; resolve(result); &#125; &#125;, reject); &#125; &#125;); &#125;&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"http://lsw.name/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"}]},{"title":"React-Redux","slug":"react-redux","date":"2017-06-10T13:18:28.000Z","updated":"2018-07-11T14:34:48.358Z","comments":true,"path":"product-design//1497100708.html","link":"","permalink":"http://lsw.name/product-design/1497100708.html","excerpt":"","text":"react-reduxredux :进行一种统一管理的类库(适用于任何技术体系的项目) 只要两个或者多个组件之间想要实现信息的共享，都可以基于 redux 解决，把共享的信息存储到 redux 容器中进行管理=&gt;购物车的案例 还可以使用 redux 做临时存储:页面加载的时候，把从服务器获取的数据信息存储到 redux 中，组件渲染需要的数据，从 redux 中获取，这样只要页面不刷新，路由切换的时候，再次渲染组件不需要重新服务器拉取数据，直接从 redux 中获取即可；页面刷新，从头开始(优化 性能，localStorage 也可以，这套方案可以代替本地存储 原理 /** * 创建建redux容器的 * @param reducer 函数 * @return * store&#123; * getState, * dispatch, * subscribe * &#125; */function createStore(reducer) &#123; //创建一个store=&gt;state用来存储的状态信息，listenAry用来存储事件池中的方法 //state不用设置初始值，因为第一次dispatch，state没有值，走的是reducer中赋值的默认值信息，我们自己会在创建容器的时候就把dispatch执行一次 let state, listenAry = []; //基于dispatch实现任务派发 function dispatch(action) &#123; //1.执行reducer，修改容器中的状态，把reducer的返回值替换原有的state,值得注意的是，我们把返回值全部替换state，所有要求reducer中在修改状态之前，要先把原始的状态信息克隆一份，在进行单个的属性修改 state = reducer(state, action); //2.通知事件池中的方法执行 for (let i = 0; i &lt; listenAry.length; i++) &#123; let item = listenAry[i]; if (typeof item === \"function\") &#123; item(); &#125; else &#123; listenAry.splice(i, 1); i--; &#125; &#125; &#125; dispatch(&#123; type: \"_INIT_DEFAULT_STATE\" &#125;); //创建容器的时候执行一次dispatch，目的是把reducer中的默认初始状态信息赋值给redux容器中的状态 //获取容器中的最新信息 function getState() &#123; //我们需要保证返回的状态信息不能和容器中的state是同一个堆内存(否则外面获取状态信息后，直接可以修改容器中的状态了，这不符合dispatch-&gt;reducer才能改状态的规范) //[浅克隆] &#123;...state&#125; 如果属性值中还有对象类型，则克隆的是地址 //[深克隆] JSON.parse(JSON.stringify(state)) return JSON.parse(JSON.stringify(state)); //深度克隆对象 &#125; //事件池追加方法 function subscribe(fn) &#123; //向容器中追加方法(去重处理) let isExist = listenAry.includes(fn); !isExist ? listenAry.push(fn) : null; //返回一个方法：执行返回的方法会把当前绑定的方法在事件池中移除掉 return function unsubscribe() &#123; let index = listenAry.indexOf(fn); //listenAry.splice(index,1);可能会引发数组坍陷 listenAry[index] = null; &#125;; &#125; return &#123; dispatch, getState, subscribe &#125;;&#125;let reducer = (state = &#123;&#125;, action) =&gt; &#123; //state原有的状态信息 action是dispatch派发任务时候传递的行为对象 let &#123; type &#125; = action; switch ( type //... 通过type的不同修改state信息，执行不同的修改操作 ) &#123; &#125; //将最新的state返回替换原有的 return state;&#125;;// //用法// let store = createStore(reducer);//create的时候把reducer传递进来，但是此时reducer并没有执行呢，只有 dispatch的时候才执行，通过执行reducer修改容器中的状态// store.dispatch(&#123;type: ''&#125;);//// let ary = [1, 2, 3, null];// ary.forEach((item, index) =&gt; &#123;// item === null ? ary.splice(index, 0) : null//// &#125;);/** * @PARAMS 对象，对象中包含每一个版块对象的reducer=&gt;&#123;xxx:function reducer()&#123;&#125;&#125; * @RETURN 返回的是一个新的reducer函数(把这个值赋值给create-store) * 特殊处理: 合并reducer之后，redux容器中的state也变为以对应对象管理的模式=&gt;&#123;xxx:function()&#123;&#125;&#125; */function combineReducers(reducers) &#123; //reducers:传递进来的reducer对象集合 /* * &#123; * custom:function reducer ()&#123;&#125; * &#125; * */ return function reducer(state = &#123;&#125;, action) &#123; //DISPATCH派发执行的时候，执行的是返回的reducer，这里也要返回一个最终的state对象替换原有的state，而且这个state中需要包含每个模块的状态信息=&gt;&#123;custom:...,personal:....&#125; //我们所谓的reducer合并，其实就是dispatch派发的时候，把每一个模块reducer都单独执行一遍，把每个模块返回的状态最后汇总在一起，替换容器中的状态信息 let newState = &#123;&#125;; for (let key in reducers) &#123; if (!reducers.hasOwnProperty(key)) break; //reducers[key]每个模块单独的reducer //state[key]当前模块在redux容器中存储的状态信息 //返回值是当前模块最新的状态，把它在放到newState中 newState[key] = reducers[key](state[key], action); &#125; return newState; &#125;;&#125; react-reduximport React from \"react\";import PropTypes from \"prop-types\";import action from \"../store/action\";/** * 'PROVIDER' 当前项目的根组件 * 1.接受通过属性传递进来的store，把store挂载到上下文中，这样当前项目中任何一个组件中，想要redux中的store，直接通过上下文获取即可 * 2.在组件的render中把传递给provider的子元素渲染 */class Provider extends React.Component &#123; //设置上下文信息类型 static childContextTypes = &#123; store: PropTypes.object &#125;; //设置上下文信息值 getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; constructor(props, context) &#123; super(props, context); &#125; render() &#123; return this.props.children; &#125;&#125;/** * connect 高阶组件(基于高阶函数:柯理化函数)创建的组件就是高阶组件 * @PARAMS * - mapStateToProps回调函数 把redux中的部分状态信息(方法返回的内容)挂载到指定组件的属性上 * - mapDispatchToProps回调函数 把一些需要派发的任务方法也挂载到组件的属性上 * @RETURN * 返回一个新的函数 * @PARAMS connect-hot()传递要操作的组件，我们需要把指定的属性和方法都挂载到当前组件属性和方法上 * @RETURN 返回一个新的组件Proxy(代理组件)，在代理组件中，我们要获取Provider在上下文中存储的store，紧接着获取store中的state和dispatch，把mapStateToProps、mapDispatchToProps回调函数执行，接受返回的结果，在把这些结果挂载到Component这个要操作的组件 */let mapStateToProps = state =&gt; &#123; //state是redux荣全国中的状态信息 return &#123; /*return对象中有啥，就把啥挂载到属性*/ &#125;;&#125;;let mapDispatchToProps = dispatch =&gt; &#123; //dispatch:store中的dispatch return &#123; /*有哪些方法就挂载到属性上,返回的方法中有执行dispatch派发任务的操作*/ &#125;;&#125;;function connect(mapStateToProps, mapDispatchToProps) &#123; return function connectHOT(Component) &#123; return class Proxy extends React.Component &#123; //获取上下文中的store static contextTypes = &#123; store: PropTypes.object &#125;; //获取store中的state和dispatch，把传递的两个回调函数执行，接受返回的结果 constructor(props, context) &#123; super(props, context); this.state = this.queryMountProps(); &#125; //基于redux中的subscribe向事件池中追加一个方法，当容器中状态改变，我们需要重新获取最新的状态信息，并且重新把component渲染，把最新的状态信息通过属性属性传递给component componentDidMount() &#123; this.context.store.subscribe(() =&gt; &#123; this.setState(this.queryMountProps()); &#125;); &#125; //渲染component组件，并且把获取的信息(状态、方法)挂载到组件属性上 render() &#123; /*&#123;...this.state&#125;这里的括号给js运行环镜*/ return &lt;Component &#123;...this.state&#125; /&gt;; &#125; //从redux中获取最新的信息，基于回调函数筛选，返回的是需要挂载到组件属性上的信息 queryMountProps = () =&gt; &#123; let &#123; store &#125; = this.context, state = store.getState(); let propsState = typeof mapStateToProps === \"function\" ? mapStateToProps(state) : &#123;&#125;; let propsDispatch = typeof mapDispatchToProps === \"function\" ? mapDispatchToProps(store.dispatch) : &#123;&#125;; return &#123; ...propsState, ...propsDispatch &#125;; &#125;; &#125;; &#125;;&#125;//export default connect(state=&gt;(&#123;...state.custom&#125;),action.custom)(VoteBase); 得到的结果是Proxy中嵌套了一个Component，不是只返回了一个Componentexport &#123; Provider, connect &#125;; redux 中间件 redux-logger 能够在控制台，清晰的展示出当前 redux 操作的流程和信息(原有状态、派发信息、修改后的状态信息) redux-thunk 处理异步的 dispatch 派发 redux-promise 在 dispatch 派发的时候支持 promise 操作","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://lsw.name/tags/React/"}]},{"title":"Vue的路由","slug":"vue的路由","date":"2017-05-30T11:10:22.000Z","updated":"2018-07-14T02:29:58.905Z","comments":true,"path":"product-design//1496142622.html","link":"","permalink":"http://lsw.name/product-design/1496142622.html","excerpt":"","text":"路由 vue 路由的两种模式 哈希值 # 开发使用 当前地址不会改变 history 直接将 url 变了 需要后台配合 上线的时候使用，history 操作浏览器的历史记录 /*history*/console.log(history); //history的属性参数//go(n) n&gt;0前进几页 n&lt;0 回退几页//forward() 前进一页 类似于go(1)//back() 回退一页 类似于go(-1)//pushState(null(路径参数),null(title值),url);url加的地址必须是同源，原来的历史记录上加一条历史记录，并且url地址栏显示新加的记录，但是页面不跳转//replaceState(null,null,url);将当前的记录替换成变为url，页面也不跳转 路由 1.定义组件 2.路由器的映射表 一个路径去匹配一个组件 3.初始路由=&gt;构造函数的方式 4.在 vue 的实例上注册路由组件上有两个属性 $router(放的函数) $route(放的属性) $router 中有常用的 go back forward push replace //需要导入vue-routerlet home = &#123; template: \"&lt;h1&gt;home&lt;/h1&gt;\", methods: &#123; goList() &#123; this.$router.push(\"/list\"); //跳转到... //this.$router.replace('/list');//直接替换 &#125; &#125;&#125;;let routes = [ &#123; path: \"/home\", component: home, path: \"/\", component: home, //首次打开默认的路径就是`/` path: \"/*\", redirect: home //重定向，当都没匹配到，就走最后一个 &#125;];let router = new VueRouter(&#123; routes, //映射表 linkActiveClass: \"xx\" //自定义类名 /*路由默认使用的方式是hash的方式*/&#125;);let vm = new Vue(&#123; el: \"#app\", data: &#123;&#125;, router //注册路由&#125;); &lt;router-link to=\"/home\" tag=\"button\"&gt;&lt;/router-link&gt;&lt;!--默认渲染成a标签,tag属性可以指定渲染成什么样的标签--&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;!--路由对应的组件显示位置--&gt; 路由嵌套 &lt;div id=\"app\"&gt; &lt;router-link to=\"/home\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/list\"&gt;列表&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;template id=\"home\"&gt; &lt;h1&gt;首页&lt;/h1&gt;&lt;/template&gt;&lt;template id=\"list\"&gt; &lt;div&gt; &lt;router-link to=\"/list/list1\"&gt;列表一&lt;/router-link&gt; &lt;router-link to=\"/list/list2\"&gt;列表二&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; let home = &#123; template: \"#home\"&#125;;let list = &#123; template: \"#list\"&#125;;let list1 = &#123; template: \"&lt;h2&gt;list1&lt;/h2&gt;\"&#125;;let list2 = &#123; template: \"&lt;h2&gt;list2&lt;/h2&gt;\"&#125;;let router = &#123; routes: [ &#123; path: \"/home\", component: home &#125;, &#123; path: \"/list\", component: list, children: [ &#123; //子路由，嵌套中path中不能带'/' path: \"list1\", component: list1 &#125;, &#123; path: \"list2\", component: list2 &#125; ] &#125; ]&#125;; 保存本地存储 根据当前的哈希值计算 记录在本地存储中 localStorage 只要不是清除浏览器缓存就会永久保存 存储的时候注意存储的是字符串 localStorage.setItem('xxx',JSON.stringify(xxx));//存储数据JSON.parse(localStorage.getItem('xxx));//根据存取的属性从本地获取存储的数据","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://lsw.name/tags/Vue/"}]},{"title":"Vue 的组件","slug":"vue的组件","date":"2017-05-26T11:10:22.000Z","updated":"2018-07-11T14:35:21.648Z","comments":true,"path":"product-design//1495797022.html","link":"","permalink":"http://lsw.name/product-design/1495797022.html","excerpt":"","text":"Vue全局组件和局部组件 全局组件 组件都是独立的，有独立的生命周期和数据(data 必须是一个函数，可能一个组件多次使用，这样才能保证数据不受干扰) 定义了就可以使用 Vue.component(\"vbox\", &#123;&#125;); //('组件名',&#123;&#125;) &lt;div id=\"app\"&gt; &lt;vbox&gt;&lt;/vbox&gt;&lt;/div&gt;&lt;script &gt; Vue.component('vbox',&#123; tempalte:'&lt;div&gt;&#123;&#123;msg&#125;&#125;组件&lt;/div&gt;', data()&#123; return&#123; mag:'全局' &#125; &#125; &#125;)&lt;/script&gt; 局部组件 1.定义组件 2.注册组件 3.使用组件 &lt;div id=\"app\"&gt; &lt;component1 :i=\"index\"&gt;&lt;/component1&gt;&lt;/div&gt; //1.定义组件let component1 = &#123; template: \"&lt;div&gt;&lt;h1&gt;&lt;/h1&gt;&lt;/div&gt;\", //props:[i],//父组件给子组件传递数据:数组 props: &#123; //对象，属性校验问题 m: &#123; type: Number, //type:[Number,String] required: true, //必须填的 default: 100, //默认值 /*自定义校验*/ validator(val) &#123; //val接受传过来的值 return true; //或者false 通没通过检验 &#125; &#125; //可以省略写 m:[Number,String] 只检测类型 &#125;&#125;;//2.注册组件let vm = &#123; el: \"#app\", data: &#123; index: 1 &#125;, components: &#123; component1 &#125;&#125;;//3.使用组件,在vm的html结构中，当成标签名使用 组件中的嵌套 注意：使用自己的数据 &lt;div id=\"app\"&gt; &lt;parent&gt;&lt;/parent&gt;&lt;/div&gt;&lt;template id=\"temp1\"&gt; &lt;div @change-money:'change'&gt; &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;son&gt;&lt;/son&gt; &lt;/div&gt;&lt;/template&gt; //嵌套组件中 使用自己的数据let son = &#123; template: \"&lt;h2 @click='click'&gt;vue&lt;/h2&gt;\", methods: &#123; click() &#123; this.$emit(\"change-money\", 1000); //发布属性，传属性 &#125; &#125;&#125;;let parent = &#123; template: \"#temp1\", data() &#123; return &#123; name: \"VUE\" &#125;; &#125;, components: &#123; son &#125;, methods: &#123; change(res) &#123; this.name += res; &#125; //让子组件去控制 &#125;&#125;;let vm = new Vue(&#123; el: \"#app\", data: &#123;&#125;, components: &#123; parent &#125;&#125;); sync &lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123;money&#125;&#125;,&#123;&#123;s&#125;&#125;&lt;/h2&gt; &lt;child :m.sync=\"money\" :s.sync=\"s\"&gt;&lt;/child&gt;&lt;/div&gt;&lt;!-- 语法糖 .sync --&gt;&lt;template id=\"child\"&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;m&#125;&#125;&lt;/h2&gt; &lt;button @click=\"getMore\"&gt;SYNC&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; let vm = new Vue(&#123; el: \"#app\", data: &#123; money: 100, s: \"vue\" &#125;, components: &#123; child: &#123; template: \"#child\", props: [\"m\", \"s\"], methods: &#123; getMore() &#123; this.$emit(\"update:m\", 1000); this.$emit(\"update:s\", \"VUE\"); &#125; &#125; &#125; &#125;&#125;); 组件中的is &lt;div id=\"app\"&gt; &lt;Component :is=\"组件变量\"&gt;&lt;/Component&gt;&lt;/div&gt; 问题是只能放一个组件，组件切换的时候就是销毁之前的组件重建新的组件 这样会比较浪费性能 用keep-alive 标签包裹起来，这样组件不会销毁，只是类似缓存的保存起来 组件中常用到的插槽 &lt;template id=\"box\"&gt; &lt;slot name=\"a\"&gt;&lt;/slot&gt; &lt;slot name=\"b\"&gt;&lt;/slot&gt; &lt;slot name=\"c\"&gt;&lt;/slot&gt; &lt;slot name=\"default\"&gt;&lt;/slot&gt;&lt;!--default这里放的是没有slot属性的标签 可以省略default--&gt; &lt;slot name=\"l\"&gt;&lt;h3&gt;ll&lt;/h3&gt;&lt;/slot&gt;&lt;!--没有匹配对应的name，显示slot的内容--&gt;&lt;/template&gt; 注意使用这个 template 局部组件，需要 3 步骤 &lt;div id=\"app\"&gt; &lt;box&gt; &lt;div slot=\"a\"&gt;&lt;/div&gt; &lt;div slot=\"b\"&gt;&lt;/div&gt; &lt;div slot=\"c\"&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/box&gt;&lt;/div&gt;","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://lsw.name/tags/Vue/"}]},{"title":"Vue的生命周期","slug":"vue的生命周期","date":"2017-05-22T11:10:22.000Z","updated":"2018-07-14T02:29:58.715Z","comments":true,"path":"product-design//1495451422.html","link":"","permalink":"http://lsw.name/product-design/1495451422.html","excerpt":"","text":"生命周期let vm = new Vue(&#123; el: \"#app\", beforeCreate() &#123;&#125;, //初始化数据之前，在这里获取不到data中数据 created() &#123;&#125;, //数据初始化完成 可以获取和操作data的中的数据，一般请求数据在这里执行 beforeMount() &#123;&#125;, //挂载之前 判断渲染模板正确与否 mounted() &#123; this.$nextTick(() =&gt; &#123;&#125;); //等DOM渲染完成之后再做执行 &#125;, //挂载完成 视图就渲染了，一般操作元素在这，vue提供了一个ref的属性 beforeUpdate() &#123;&#125;, //数据更新之前 updated() &#123;&#125;, //数据更新完成 一般使用watch代替 beforeDestroy() &#123;&#125;, //销毁之前 destroyed() &#123;&#125; //销毁完成&#125;);vm.$destroy(); //手动销毁实例，以前渲染好的和实例还在，相当于当前的vm与挂载好的内容没有关系，当实例操作时，不会再影响页面 局部组件的生命周期 组件的数据修改只会触发自己的 beforeUpdate 和 updated 不会触发父组件的生命周期 ref vue 提供的 给想要获取的元素加一个属性 ref=’值’,如果设置重复，因为 ref 存取的是对象形式属性名不能重复，只能获取后面的一个 如果是循环的元素，会把所有的循环得到的元素放到一个数组里面 获取的值在$refs 属性里 &lt;div ref=\"name\"&gt;&lt;/div&gt;&lt;div v-for=\"item in items\" ref=\"p\"&gt;&lt;/div&gt; 可以给组件添加一个 ref 的属性，在 vue 的实例中可以通过$refs 获取使用","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://lsw.name/tags/Vue/"}]},{"title":"Vue的过渡动画","slug":"vue过渡动画","date":"2017-05-19T09:10:22.000Z","updated":"2018-07-14T02:29:58.965Z","comments":true,"path":"product-design//1495185022.html","link":"","permalink":"http://lsw.name/product-design/1495185022.html","excerpt":"","text":"Vue 的过渡动画和 animate vue 中提供的有特殊意义的自定义标签 也叫组件 使用这个标签包起来的内容加上一些自定义动画的效果(transition) &lt;link rel=\"stylesheet\" href=\"css/animate.css\"&gt;&lt;style&gt; .box&#123; width: 200px; height: 200px; background: yellow; &#125; .fadeIn-enter&#123;opacity: 0&#125; .fadeIn-enter-active&#123;transition: all 2s&#125; .fadeIn-leave-active&#123;transition: all 1s;opacity: 0&#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;transition name=\"fadeIn\"&gt; &lt;div class=\"box\"&gt;&lt;/div&gt; &lt;/transition&gt; &lt;transition enter-active-class=\"animated bounceInLeft\" leave-active-class=\"animated bounceOutRight\"&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el:'#app', data:&#123;&#125; &#125;)&lt;/script&gt;","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://lsw.name/tags/Vue/"}]},{"title":"Vue的指令","slug":"vue的指令","date":"2017-05-17T05:10:22.000Z","updated":"2018-07-14T02:29:58.255Z","comments":true,"path":"product-design//1494997822.html","link":"","permalink":"http://lsw.name/product-design/1494997822.html","excerpt":"","text":"vue 中常用的指令 ‘v-xxx’&lt;!--都是指标签的显示隐藏，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。--&gt;&lt;input type=\"text\" v-show=\"true\"&gt;&lt;!--操控的是元素样式，display--&gt;&lt;input type=\"text\" v-if=\"true\"&gt;&lt;!--remove元素 移除元素--&gt;&lt;input type=\"text\" v-for=\"item in data\"&gt;&lt;!--循环标签 类似于for..in..--&gt;&lt;input type=\"text\" v-bind:class=\"box\"&gt;&lt;!--动态的获取属性值 可以省略v-bind 多个值可以用数组代替--&gt;&lt;input type=\"text\" @click=\"click\"&gt;&lt;!--给元素绑定事件 在标签写可以这样写onclick=fn()--&gt;&lt;input type=\"text\" @click.once=\"click\"&gt;&lt;!--事件修饰符 .once只触发一次 .stop阻止冒泡 .prevent阻止默认行为 .capture事件发生在捕获阶段 .self自己作为事件源的时候才会发生--&gt;&lt;!--按键修饰符 .enter .tab .delete(捕获\"删除\"和\"退格键\") .esc .space .up .down .left .right --&gt;&lt;!--写括号，必须传参，如果用到事件对象必须手传($event)，不写括号的时候默认传事件对象--&gt; 自定义指令 &lt;div id=\"app\"&gt; &lt;div v-color=\"red\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; let vm=&#123; el:'#app', data:&#123;&#125;, //定义的指令 directives:&#123; color(el,&#123;value&#125;)&#123;//el当前操作的元素,第二个参数为一个对象，有一个value就是使用指令时候赋的值 el.style.color=value; &#125; &#125; &#125;&lt;/script&gt;","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://lsw.name/tags/Vue/"}]},{"title":"Vue的MVVM以及双向数据绑定","slug":"vue","date":"2017-05-10T13:05:33.000Z","updated":"2018-07-14T02:29:59.015Z","comments":true,"path":"product-design//1494421533.html","link":"","permalink":"http://lsw.name/product-design/1494421533.html","excerpt":"","text":"Vue介绍 MVVM 框架 MVVM 是 model-View-ViewModel 的简写，本质上就是 MVC 的改进版，MVVM 就是将其中的 View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。 ## 双向数据绑定的原理以及传入的参数 在 vue 中,可以引入一个 vue.js，通过创建 vue 的实例来初始化 &lt;div id=\"app\"&gt; &#123;&#123;name&#125;&#125; &lt;input type=\"checkbox\" v-model=\"value\"&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123; el:'#app',//元素ID或类名 data:&#123;//初始化数据=&gt;数据必须声明后才能使用, name:'Hello' , value:false &#125;, methods:&#123;//绑定事件,方法写在这&#125;, mounted()&#123;&#125;,//页面初始化完成，获取元素可以在这里面写 filters:&#123;//过滤器 toFixed(target,n)&#123;//target,n 默认是传的参数 n是手动传的参数 return target //必须有返回值 函数的返回值是字符串 &#125; &#125;, computed:&#123;//计算属性，在这里写的数据不能在data中声明 ss:&#123; get()&#123;&#125;,//必须写返回值，否则得不到值，第一次获取的时候，依赖值没有发生改变但是也会默认执行一次 set()&#123;&#125; &#125; &#125;, watch:&#123;//watch监控的属性是data中的属性，监控的都是直接的属性 val:&#123;//属性里面的属性值都是固定的 handler(newVal,oldVal)&#123;//(新值，旧值) &#125;, immediate:true,//，默认第一次不执行，加上这个属性，第一次执行一下，旧值为undefined deep:true//深度检测，可以检测对象的具体属性的改变 &#125; &#125;&#125;);vm.name='hello';vm.$set(vm.obj,name,'world');&lt;!--vue中如果是改变数组中的某一项，推荐数组重新赋值--&gt;&lt;/script&gt; 利用 JS 模拟双向数据绑定 原理是 OBject.defineProperties() &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"value\"&gt;&lt;/div&gt;&lt;script&gt; let app = document.querySelector('#app'), input = app.querySelector('input'); let data=&#123;value:''&#125;; input.onchange=function() &#123; data[this.getAttribute('v-model')]=this.innerHTML; &#125;; Object.defineProperties(data,&#123; value:&#123; set(val)&#123; input.inner=val; &#125; get()&#123; return ''//返回的什么值就是什么 &#125; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://lsw.name/tags/Vue/"}]}]}