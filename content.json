{"meta":{"title":"文艺青年","subtitle":"关注技术和人文的原创IT博客","description":"前端，博客，个人博客","author":"刘某某","url":"http://lsw.name"},"pages":[{"title":"移动互联网？","date":"2017-03-18T11:56:20.000Z","updated":"2018-06-26T15:39:02.575Z","comments":false,"path":"app/index.html","permalink":"http://lsw.name/app/index.html","excerpt":"","text":"憋闹了，还没App。网页写的差不多了，再考虑写移动互联网….public static void main(String args[]) throws Exception &#123; for (int i = 0; ; i++) &#123; Thread.sleep(1000); System.out.println(\"嗯、写码，呵呵...\" + i); &#125;&#125; fyiguhjnwkefnmwoeih68yuih4jnkrfewdfyugbijnk.wfww3f 5jhyrtgve5jhytbgvef5grefvqwu6ejynhbvwer5jr5hb4gevgwh54uh3g4weab eh43eg223t4whretbvfw345u36jhtbevww32q4wu5ejhtbevwgw354uhtbgevfcewg 擦了下键盘，这些你可以拿去当QQ密码，绝不会被盗号，不用谢！"},{"title":"为何建站 && 为何写作","date":"2017-02-07T05:23:07.000Z","updated":"2018-06-26T08:12:33.376Z","comments":false,"path":"about/index.html","permalink":"http://lsw.name/about/index.html","excerpt":"","text":"为何建站在我年轻的时候，独立站长曾是一个牛逼闪闪的角色，然而现在不那么神秘了。搭建说IT这个网站主要是为了记录技术成长的点滴，当然装逼也是一个目的。 为何写写作 读的书越多，你会发现知道的东西越多，不知道的东西就更多了，不知道远远大于知道，于是你在两者间不断碰撞、焦虑、欢喜、忧伤，产生各种思想、情感和故事，记录下来，就是文章。 引自《MacTalk》跨越边界 显然，写作是个艺术活儿，这个博客是带有某种程序员感情的，如果你是这种艺术家，那就能共震了！ 本站主要作为技术笔记存档，内容主要涉及前端开发（含移动端），偶尔可能也会有一些碎碎念、开开车。如果某一篇帮助了你，请记得点个赞。 作为内容站，持续输出高质量的内容是件不太容易的事情，本站的任何文章，你可任意转载，但请保留原文链接。如有兴趣，欢迎一起码字。 关于作者斜杠中年、文字控、周杰伦迷，就职于粗粮厂的90后程序猿。目前致力于JavaScript大法，ReactNative是目前的工作。鸡汤一站，请自取一篇饮 如果您遇到麻烦或对本站有疑问，请在本站找到那个白色❓号并点击查看 没时间再解释了，赶紧上车…"},{"title":"QA - 帮助那个中心...","date":"2017-03-29T10:49:38.000Z","updated":"2018-06-26T15:39:51.509Z","comments":true,"path":"help/index.html","permalink":"http://lsw.name/help/index.html","excerpt":"","text":"这里不发表情，准备说点严肃、实在的…Q: 这网站怎么弄的，还挺好看的啊？ A: 本站是静态博客，通过hexo生成，主题是我自己写的。免费使用，已开源至GitHub，本站底部有它们的链接 Q: 为什么博客有时候打开速度很慢，一直在加载呢？ A: 评论组件使用的Disqus等资源的服务器在墙外，你懂的…(不懂问搜狗)。不过不影响文章阅读。 Q: 我也想用这个主题搭个博客，不知道怎么弄？ A: 先去hexo官网看看，学会用这个写作并学会使用gitpages之类的部署博客。教程谷歌一下遍地皆是。主题是免费的，在本站底部可找到链接，根据文档自及配置就好了。遇到问题，在本页留言即可，我会很愿意帮助你的。需要注意的是主题有全站https开关，在主题_config.yml文件的fullHttps处配置。如配置不当r某些文件就无法正确引用，加载粗来的页面会很挫。 Q: 你这主题，我配置了怎么运行报错啊，跑不起来啊？ A: 关于使用主题出错，请先前往JSimple-issues寻找答案，说不定你遇到的问题，已经有人碰到而我也回答解决方式了。关于主题的任何问题，我都会在那里回复 Q: 无法自由翱翔互联网咋办？ A: 着急吃饭且自甘有钱的朋友请直接购买蓝灯。不着急就慢慢找吧，像GreenVPN、www.ishadowsocks.com都是很好的方案。另外有hosts方案，请前往这个项目UsefullShells Q: 如何找到一个靠谱的对象？ 如果你有资源，记得第一时间告诉我… Q: 我觉得站长你挺有意思的，能交个朋友吗？ A: 可以，来握个手吧：斜杠中年 暂时更新这些，需要什么本文底部留言……"},{"title":"嘉宾推荐","date":"2017-02-07T05:22:22.000Z","updated":"2018-06-26T15:40:22.628Z","comments":false,"path":"links/index.html","permalink":"http://lsw.name/links/index.html","excerpt":"","text":"以下摘录有趣、有意义、有影响力、有正能量的博客、资源 此处不做网址导航，因此不接受以SEO为目的的友链。排序不分那啥… JS大法系 阮一峰博客闲情写手腾讯AlloyTeam 苹果派 王巍（喵神）的博客Objc.ioSwifter 娱乐圈 VIMCodeTank 公众号 没有链接，请直接关注微信公众号：涔汐(zhangcenxi99)、小道消息、MacTalk等等"},{"title":"标签云","date":"2017-02-04T07:37:12.000Z","updated":"2018-06-26T15:40:40.790Z","comments":true,"path":"tags/index.html","permalink":"http://lsw.name/tags/index.html","excerpt":"","text":""},{"title":"时光轴","date":"2017-02-07T05:23:27.000Z","updated":"2018-06-26T15:41:00.720Z","comments":false,"path":"timeline/index.html","permalink":"http://lsw.name/timeline/index.html","excerpt":"","text":"时光轴嘛，得先有时光，会更新的，别急……"}],"posts":[{"title":"React 的 MVC 模式、脚手架以及把 JSX 渲染为真实的 DOM 原理","slug":"react的MVC模式、脚手架以及把JSX渲染为真实的DOM原理","date":"2017-07-01T14:14:28.000Z","updated":"2018-07-11T14:51:18.798Z","comments":true,"path":"product-design//1498918468.html","link":"","permalink":"http://lsw.name/product-design/1498918468.html","excerpt":"","text":"React简述 MVC 框架 MVC 是一种使用 MVC(Model View Controller 模型-视图-控制器)设计创建 Web 应用程序的模式 Model(模型)可以简单的理解为数据层，用于提供数据。对数据库的操作这一些的代码作为 model 层， View(视图)是应用程序中处理数据显示的部分，通常视图是依据模型数据创建的，一般所有的 JSP、HTMl 等页面就是 View 层 Controller(控制器)功能就是将 Model 和 View 层进行关联，比如 View 主要是显示数据的，但是数据又需要 Model 去访问，这样的话，View 会先告诉 Controller，然后 Controller 再告诉 Model，Model 请求完数据之后，再告诉 View。这样 View 就可以显示数据了 React 脚手架 前端的工程化开发 划分组件开发 基于路由的 SPA 单页面开发 一般都是基于 ES6 来编写代码(最后部署上线的时候，我们需要把 ES6 编译为 ES5=&gt;基于 babel 来完成编译) 可能用到 Less/Sass 等，我们也需要对应的插件把他们进行预编译 最后为了优化性能，减少 http 请求的次数，我们需要把 js/css 进行合并压缩 webpack 来完成以上页面组件合并、js/css 编译加合并等工作 创建脚手架 安装create-react-app npm install create-react-app -g 基于create-react-app [项目名称]脚手架的命令，创建一个基于 react 的自动化/工程化项目目录，项目名称中不能出现大写字母、中文汉字，特殊符号(-或者_是可以)等 脚手架生成目录中的一些内容 node_modules 当前项目中依赖的包都安装在这里(.bin 本地项目中可执行的命令，在 package.json 的 scripts 中配置对应的脚本命令) public 存放的是当前项目的 HTML 页面(单页面应用放一个 index.html 即可，多页面根据自己需求放置需要的页面) src 项目结构中主要的目录，因为后期所有的 JS、路由、组件都是放到这里面(包括需要编写的 css 或者图片等)，index.js 是当前项目的主入口文件 .gitignoregit 提交时候，忽略提交文件的配置项 package.json 当前项目的配置清单,基于脚手架生成工程目录，自动帮我们安装了三个模块:react/react-dom/react-scripts,react-scripts 集成了 webpack 需要的内容(编译包：babel 一套，css 处理的一套，eslint 一套，webpack 一套，其他的，没有 less/sass 的处理内容，项目中若是使用 less，我们需要自己额外的安装) //package.json&#123; \"dependencies\": &#123; \"react\": \"^16.4.1\", \"react-dom\": \"^16.4.1\", \"react-scripts\": \"1.1.4\" &#125;, \"scripts\": &#123; \"start\": \"react-scripts start\" /*开发环镜下，基于webpack编译处理，最后可以预览当前开发的项目成果(在webpack中安装了webpack-dev-server插件，基于这个插件会自动创建一个web服务[端口号默认是3000]，webpack会默认打开浏览器，并展示我们的页面，并且能够监听我们代码的改变，如果代码改变，webpack会自动重新编译，并且刷新浏览器完成重新渲染)*/, \"build\": \"react-scripts build\" /*项目需要部署到服务器上，我们先执行yarn build，把项目整体编译打包 (完成后会在项目中生成一个build文件夹，这个文件夹中包含了所有编译后的内容，我们把它上传到服务器即可),而且在服务上进行部署的时候，不需要安装任意的模块*/, \"test\": \"react-scripts test --env=jsdom\", \"eject\": \"react-scripts eject\" &#125;&#125; public 中路径的问题&lt;link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\"&gt;&lt;link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\"&gt; 在 react 当中，所有的逻辑都是在 jS 中完成的(包括页面结构的创建)，如果想给当前页面导入一些 css 样式或者 img 图片等内容，我们有两种方式， 第一种在 JS 中基于 es6 module 模块规范，使用 import 导入，这样 webpack 在编译合并 JS 的时候，会把导入的资源文件等插入到页面的结构中(绝对不能在 js 管控的结构中通过相对目录./或者../,导入资源) ，因为 webpack 编译的时候，地址就不在是 之前的相对路径 第二种，如果不想在 js 中导入(JS 中导入的资源最后都会基于 webpack 编译，我们也可以把资源手动的在 HTML 中导入，但是 HTML 最后 也要基于 webpack 编译，导入的地址也不建议写相对地址，而是使用%public_URL%写成绝对地址) 脚手架的深入 create-react-app 脚手架为了结构目录清晰，把安装的 webpack 及配置文件都集成在了 react-scripts 模块上，放到了 node_modules 中 真实项目中，我们需要在脚手架默认安装的基础上，额外安装一些我们需要的模块，例如：react-router-dom/axios/…,再比如 less/less-loader… 情况一：如果我们安装其他的组件，但是安装成功后不需要修改 webpack 的配置项，此时我们直接安装，并且调取使用即可 情况二：我们安装的插件是基于 webpack 处理的，也就是需要把安装的模块配置到 webpack 中，需要重新修改 webpack 配置项了： 首先需要把隐藏到 node_modules 的配置项暴露到项目中yarn eject,首先会提示确认是否执行 eject 操作，这个操作是不可逆的，一旦暴露出来配置项，就无法隐藏回去了，如果当前的项目基于 git 管理，会报错，提醒你提交到历史区 再去修改对应的配置项即可，一旦暴露后，项目目录中多了两个文件夹：config 存放的是 webpack 的配置文件(webpack.config.dev.js 开发环镜下的配置项-yarn start，webpack.config.prod.js 生产环镜下的配置项-yarn build)，scripts 存放的是可执行脚本的 js 文件(start.js/build.js/test.js=&gt;yarn xxx 对应) package.json 也改变了， 例如 less less 是开发和生产环镜下都需要配置的 我们预览项目的时候，也是基于 webpack 编译，把编译后的内容放到浏览中运行，所以如果项目中使用了 less，我们需要修改 webpack 配置项，在配置项中放入 less 的编译工作，这样后期预览项目，首先基于 webpack 编译成 css，再呈放到页面中 环镜变量的修改、协议、端口号 set HTTPS=true&amp;&amp;yarn start 开启 HTTPS 协议 设置环镜变量 HTTPS 的值 set PORT=63341&amp;&amp;yarn start 修改端口 react&amp;&amp;react-dom [渐进式框架] 目前最流行的框架设计思想，一般框架中包含很多内容，这样导致框架的体积过于臃肿，不利于页面的优化，真实项目中，我们使用一个框架，不一定用到所有的功能，此时我们应该把框架的功能拆分，用户想用什么，让其自己自由组合即可 [全家桶] 渐进式框架 N 多部分的组合 vue 全家桶:vue-cli/vue/vue-router/vuex/axios(fetch)/vue element(vant) react 全家桶:creatr-react-app/react/react-dom/react-router/redux/react-redux/axios/ant/dva/saga/mobx react:react 框架的核心部分，提供了 Component 类可以供我们进行组件开发，提供了钩子函数(生命周期函数:所有的生命周期函数都是基于回调函数完成的)react-dom:把 jsx 语法(react 独有的语法)渲染为真实的 DOM(能够放到页面中展示的结构都叫做真实的 DOM)的组件 把 JSX(虚拟 DOM)变为真实的 DOM//导入组件import React from 'react';import ReactDOM from 'react-dom';//语法ReactDOM.render([jsx],[container],[callback]);把jsx元素渲染到页面中 jsx：react虚拟元素 container容器，我们想把元素放到页面中的哪个容器中 callback：当把内容放到页面中呈现触发的回调函数 JSX：react 独有的语法 javascript+XML(HTML) 和我们之前自己拼接的 HTML 字符串类似，都是把 HTML 结构代码和 JS 代码或者数据混合在一起了，但是他不是字符串 在写 render 的时候的规范 1.不建议我们把 jsx 直接渲染到 body 中，而是放在自己创建一个容器中，一般我们都放在一个 ID 为 root 的 DIV 中即可*/ 2.在 JSX 中出现的{}是存放 js 的，但是要求 js 代码执行完成需要有返回结果(JS 表达式) - 不能直接放一个对象数据类型的值(对象(除了给style赋值)、数组(数组中没有对象都是基本值或者是JSX元素，这样是可以的)、函数都不行) - 可以是基本类型的值(布尔类型的值什么都不显示，但是不会报错，null、undefined也是JSX元素，代表是空) - 循环判断的语句 都不支持，但是支持三元运算符 3.循环数组创建 JSX 元素(一般都是基于数组的 MAP 方法完成迭代)，需要给创建的元素设置唯一的 key 值(当前本次循环内唯一即可) 4.只能出现一个根元素 5.给元素设置样式类用的是 className 不是 class6.style 中不能直接写样式字符串，需要基于一个样式对象来遍历赋值jsx 渲染机制 1.基于 babel 中的语法解析模块(babel-preset-react)把 jsx 语法编译为 React.createElement(…)的结构 2.执行 React.createElement(type,props,children)函数，会创建一个对象(虚拟 DOM)3.ReactDOM.render(JSX 语法最后生成的对象，容器，回调函数)，基于 Render 方法把生成的对象动态创建为 DOM 元素，插入到指定的容器中 JS 原理 //参数至少两个，type/props children这个部分可能没有可能有多个function createElement(type, props, ...childrens) &#123; //返回一个对象，创建一个对象，默认有四个属性(type,props,ref,key) //根据传递的值修改这个对象 /* * type 传递的type的值 * props 需要做一些处理:大部分传递的props属性都赋值给对象的props，有一些比较特殊 如果是ref或者key，我们需要把传递的props的这两个属性值删除掉 * 把传递的children作为新创建对象的props中的一个属性*/ props = props || &#123;&#125;; let obj = &#123; type: \"null\", props: &#123; children: \"\" &#125;, ref: null, key: null &#125;; //obj=&#123;...obj,type,props&#125;;//=&gt;&#123;type:type,props:props&#125;用传递的type和props覆盖原有的默认值 obj = &#123; ...obj, type, props: &#123; ...props, children: childrens.length &lt;= 1 ? childrens[0] || \"\" : childrens &#125; &#125;; //=&gt;把ref和key都提取出来,并且删除props中的属性 \"key\" in obj.props ? ((obj.key = obj.props.key), delete obj.props.key) : null; \"ref\" in obj.props ? ((obj.ref = obj.props.ref), (obj.props.ref = undefined)) : null; return obj;&#125;/*Render把创建的元素生成对象的DOM元素，最后插入到页面中*/function render(obj, container, callback) &#123; let &#123; type, props &#125; = obj || &#123;&#125;, newElement = document.createElement(type); for (let attr in props) &#123; if (!props.hasOwnProperty(attr)) break; //结束遍历 if (!props[attr]) continue; //继续下一个 let value = props[attr]; if (attr === \"className\") &#123; newElement.setAttribute(\"class\", value); continue; &#125; if (attr === \"style\") &#123; if (value === \"\") continue; for (let styKey in value) &#123; if (value.hasOwnProperty(styKey)) &#123; newElement.style[styKey] = value[styKey]; &#125; &#125; continue; &#125; if (attr === \"children\") &#123; /*可能是一个值:是字符串成也可能是JSX对象 或者数组 数组中的每一项可能是字符串也可能是JSX对象*/ if (!(value instanceof Array)) &#123; value = [value]; //统一变成数组方便操作 &#125; value.forEach((item, index) =&gt; &#123; //验证item是什么类型的 字符串就是创建文本节点，是对象，再次执行render方法，把创建的元素放到做开始的大盒子中 if (typeof item === \"string\") &#123; let text = document.createTextNode(item); newElement.appendChild(text); &#125; else &#123; render(item, newElement); &#125; &#125;); continue; &#125; newElement.setAttribute(attr, value); //基于setAttribute可以使设置的属性表现在HTML上 &#125; container.appendChild(newElement); callback &amp;&amp; callback();&#125;//方法的使用let obj = createElement( \"div\", &#123; id: \"box\", className: \"box\", style: &#123; color: \"red\" &#125; &#125;, createElement(\"h2\", &#123; className: \"title\" &#125;, \"\\u7CFB\\u7EDF\\u63D0\\u793A\"), createElement( \"div\", &#123; className: \"content\" &#125;, \"\\u6E29\\u99A8\\u63D0\\u793A\\uFF1A\\u8BED\\u6CD5\\u9519\\u8BEF\\uFF01\" ), \"\\u672C\\u64CD\\u4F5C\\u5C31\\u662F\\u4E00\\u4E2A\\u6D4B\\u8BD5\\uFF01\");render(obj, root, () =&gt; &#123; console.log(\"ok\");&#125;);","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://lsw.name/tags/React/"}]}]}