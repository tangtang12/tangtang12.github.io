{"meta":{"title":"文艺青年","subtitle":"关注技术和人文的原创IT博客","description":"前端，博客，个人博客","author":"刘某某","url":"http://lsw.name"},"pages":[{"title":"为何建站 && 为何写作","date":"2017-02-07T05:23:07.000Z","updated":"2018-06-26T08:12:33.376Z","comments":false,"path":"about/index.html","permalink":"http://lsw.name/about/index.html","excerpt":"","text":"为何建站在我年轻的时候，独立站长曾是一个牛逼闪闪的角色，然而现在不那么神秘了。搭建说IT这个网站主要是为了记录技术成长的点滴，当然装逼也是一个目的。 为何写写作 读的书越多，你会发现知道的东西越多，不知道的东西就更多了，不知道远远大于知道，于是你在两者间不断碰撞、焦虑、欢喜、忧伤，产生各种思想、情感和故事，记录下来，就是文章。 引自《MacTalk》跨越边界 显然，写作是个艺术活儿，这个博客是带有某种程序员感情的，如果你是这种艺术家，那就能共震了！ 本站主要作为技术笔记存档，内容主要涉及前端开发（含移动端），偶尔可能也会有一些碎碎念、开开车。如果某一篇帮助了你，请记得点个赞。 作为内容站，持续输出高质量的内容是件不太容易的事情，本站的任何文章，你可任意转载，但请保留原文链接。如有兴趣，欢迎一起码字。 关于作者斜杠中年、文字控、周杰伦迷，就职于粗粮厂的90后程序猿。目前致力于JavaScript大法，ReactNative是目前的工作。鸡汤一站，请自取一篇饮 如果您遇到麻烦或对本站有疑问，请在本站找到那个白色❓号并点击查看 没时间再解释了，赶紧上车…"},{"title":"移动互联网？","date":"2017-03-18T11:56:20.000Z","updated":"2018-06-26T15:39:02.575Z","comments":false,"path":"app/index.html","permalink":"http://lsw.name/app/index.html","excerpt":"","text":"憋闹了，还没App。网页写的差不多了，再考虑写移动互联网….public static void main(String args[]) throws Exception &#123; for (int i = 0; ; i++) &#123; Thread.sleep(1000); System.out.println(\"嗯、写码，呵呵...\" + i); &#125;&#125; fyiguhjnwkefnmwoeih68yuih4jnkrfewdfyugbijnk.wfww3f 5jhyrtgve5jhytbgvef5grefvqwu6ejynhbvwer5jr5hb4gevgwh54uh3g4weab eh43eg223t4whretbvfw345u36jhtbevww32q4wu5ejhtbevwgw354uhtbgevfcewg 擦了下键盘，这些你可以拿去当QQ密码，绝不会被盗号，不用谢！"},{"title":"QA - 帮助那个中心...","date":"2017-03-29T10:49:38.000Z","updated":"2018-06-26T15:39:51.509Z","comments":true,"path":"help/index.html","permalink":"http://lsw.name/help/index.html","excerpt":"","text":"这里不发表情，准备说点严肃、实在的…Q: 这网站怎么弄的，还挺好看的啊？ A: 本站是静态博客，通过hexo生成，主题是我自己写的。免费使用，已开源至GitHub，本站底部有它们的链接 Q: 为什么博客有时候打开速度很慢，一直在加载呢？ A: 评论组件使用的Disqus等资源的服务器在墙外，你懂的…(不懂问搜狗)。不过不影响文章阅读。 Q: 我也想用这个主题搭个博客，不知道怎么弄？ A: 先去hexo官网看看，学会用这个写作并学会使用gitpages之类的部署博客。教程谷歌一下遍地皆是。主题是免费的，在本站底部可找到链接，根据文档自及配置就好了。遇到问题，在本页留言即可，我会很愿意帮助你的。需要注意的是主题有全站https开关，在主题_config.yml文件的fullHttps处配置。如配置不当r某些文件就无法正确引用，加载粗来的页面会很挫。 Q: 你这主题，我配置了怎么运行报错啊，跑不起来啊？ A: 关于使用主题出错，请先前往JSimple-issues寻找答案，说不定你遇到的问题，已经有人碰到而我也回答解决方式了。关于主题的任何问题，我都会在那里回复 Q: 无法自由翱翔互联网咋办？ A: 着急吃饭且自甘有钱的朋友请直接购买蓝灯。不着急就慢慢找吧，像GreenVPN、www.ishadowsocks.com都是很好的方案。另外有hosts方案，请前往这个项目UsefullShells Q: 如何找到一个靠谱的对象？ 如果你有资源，记得第一时间告诉我… Q: 我觉得站长你挺有意思的，能交个朋友吗？ A: 可以，来握个手吧：斜杠中年 暂时更新这些，需要什么本文底部留言……"},{"title":"标签云","date":"2017-02-04T07:37:12.000Z","updated":"2018-06-26T15:40:40.790Z","comments":true,"path":"tags/index.html","permalink":"http://lsw.name/tags/index.html","excerpt":"","text":""},{"title":"嘉宾推荐","date":"2017-02-07T05:22:22.000Z","updated":"2018-06-26T15:40:22.628Z","comments":false,"path":"links/index.html","permalink":"http://lsw.name/links/index.html","excerpt":"","text":"以下摘录有趣、有意义、有影响力、有正能量的博客、资源 此处不做网址导航，因此不接受以SEO为目的的友链。排序不分那啥… JS大法系 阮一峰博客闲情写手腾讯AlloyTeam 苹果派 王巍（喵神）的博客Objc.ioSwifter 娱乐圈 VIMCodeTank 公众号 没有链接，请直接关注微信公众号：涔汐(zhangcenxi99)、小道消息、MacTalk等等"},{"title":"时光轴","date":"2017-02-07T05:23:27.000Z","updated":"2018-06-26T15:41:00.720Z","comments":false,"path":"timeline/index.html","permalink":"http://lsw.name/timeline/index.html","excerpt":"","text":"时光轴嘛，得先有时光，会更新的，别急……"}],"posts":[{"title":"Promise 原理","slug":"react的路由","date":"2017-07-15T13:18:28.000Z","updated":"2018-07-11T15:07:34.433Z","comments":true,"path":"front-end//1500124708.html","link":"","permalink":"http://lsw.name/front-end/1500124708.html","excerpt":"","text":"react的路由使用 react 路由 学习 react 路由[http://reacttraining.cn/web/api/] 1.安装 yarn-add react-router-dom———-3及以前版本称为react-router———-4及最近版本称为react-router-dom 常用的方法 2.BrowserRouter vs HashRouter 它是两种常用的路由实现思想，BrowserRouter 浏览器路由，HashRouter 哈希路由[BrowserRouter]它是基于 H5 中的 history API(pushState,replaceState,popState)来保持 UI 和 URL 同步，真实项目中应用的不多，一般只有当前项目是基于服务器渲染的才会使用浏览器路由http://www.demo.com/http://www.demo.com/personalhttp://www.demo.com/personal/login[HashRouter]真实项目中(前后端分离的项目:客户端渲染)我们经常使用的哈希路由来完成的，他依据相同的页面地址，不同的哈希值，来规划当前页面中的那一个组件呈现渲染，他基于原生 JS 构造了一套类似于 history API 的机制，每一次路由的切换都是基于 history stack 完成的http://www.demo.com/#/http://www.demo.com/#/personalhttp://www.demo.com/#/personal/login HashRouter 1.当前项目一旦使用了 HashRouter，则默认在页面的地址后面加上”#/“,也就是 HASH 默认值是一个斜杠，我们一般让其显示首页组件信息内容 2.HashRouter 中只能出现一个子元素 3.HashRouter 机制中，我们需要根据哈希地址不同，展示不同的组件内容，此时需要使用 route Route path 设置匹配哈希值后面的值(地址)，但是默认不是严格匹配，当前页面哈希地址只要包含完整的它(内容是不变的)，都能被匹配上 path=’/‘ 和它匹配的地址只要有斜杠即可(都能和它匹配) path=’/user’:”#/user/login”也可以匹配，但是”#/user2”这个无法匹配 在Route加上属性exact，可以使其path严谨匹配(只有url的哈希值和path设定的值相等才可以匹配到) path=”/A” “#/A”可以被匹配 “#/“不可以匹配 在Route加上属性static，可以使其严格匹配 path=”/A/“ path=”/A/“匹配 path=”/A”不匹配 path=”/A/B”匹配 属性render：当页面的哈希地址和path匹配，会把render规划的方法执行，在方法中一般做”权限校验” (渲染组件之前验证是否存在权限，不存在做一些特殊处理) component 一旦哈希值和当前 Route 的 path 相同了，则渲染 component 指定的组件 默认情况下，会和每一个 route 都做校验(哪怕之前已经有校验成功的),switch 组件可以解决这个问题，和 Switch Case 一样，只要有 一种情况校验成功，就不在向后检验了import React from 'react';import ReactDOM,&#123;render&#125; from 'react-dom';// noinspection ES6CheckImportimport &#123;HashRouter,Route,Switch,Redirect&#125; from 'react-router-dom';import A from \"./hash/A\";import B from \"./hash/B\";import C from \"./hash/C\";render(&lt;HashRouter&gt;&lt;Switch&gt;&lt;Route path='/' component=&#123;C&#125; exact /&gt;&lt;Route path='/A' component=&#123;A&#125; /&gt;&lt;Route path='/pay' component=&#123;B&#125; /&gt;&lt;Route path='/pay1' render=&#123;()=&gt;&#123;//一般在 render 中处理的是权限校验let flag=localStorage.getItem('FLAG');if (flag&amp;&amp;flag==='SAFE')&#123;return &lt;C/&gt;;&#125;return '当前环境不安全，不利于支付'&#125;&#125; /&gt; &#123;/*上述都设置完成后，会在末尾设置一个匹配，以上都不符合的情况下，我们认为路由地址是非法的地址，我们做一些特殊处理，肉Route中path不写,就是匹配所有地址规则*/&#125; &#123;/*&lt;Route render=&#123;()=&gt;&lt;div&gt;404&lt;/div&gt;&#125; /&gt;*/&#125; &#123;/*也可以基于redirect 重定向到哪 to [string]重新定向到新的地址后的组件 to [OBJECT]重新定向到新的地址，只不过指定了更多的信息 &#123;PATHNAME:定向的地址,search:给定向的地址问号传参(结合当前案例，真实项目中，我们有时候会根据是否存在问号参数值来统计是正常进入首页还是非正常跳转过来的，也有可能根据问号传参值做不同的事情),state:给定向后的组件传递一些信息&#125; push 如果设置了这个属性，当前跳转的地址，会加入到history stack中一条记录 from 设置当前来源的页面地址 &lt;Redirect from='/custom' to='/custom/list' /&gt;如果当前请求的HASH地址是\"/custom\"，我们让其重定向到/custom/list */&#125; &#123;/*&lt;Redirect to='/?lx=404' /&gt;*/&#125; &lt;Redirect to=&#123;&#123;pathname:'/',search:'?lx=404'&#125;&#125; /&gt; &lt;/Switch&gt;&lt;/HashRouter&gt;,root);","categories":[{"name":"前端","slug":"front-end","permalink":"http://lsw.name/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://lsw.name/tags/React/"}]},{"title":"React 的生命函数","slug":"react的生命函数","date":"2017-07-11T13:45:23.000Z","updated":"2018-07-11T14:33:51.786Z","comments":true,"path":"product-design//1499780723.html","link":"","permalink":"http://lsw.name/product-design/1499780723.html","excerpt":"","text":"React生命周期函数(钩子函数) 描述一个组件或者程序从创建到销毁的过程，我们可以在过程中间基于钩子函数完成一些自己的操作(例如：在第一次渲染完成做什么，或者第二次即将重新渲染之前做什么等…) [基本流程] constructor 创建一个组件 componentWillMount 第一次渲染之前 render 第一次渲染 componentDidMount 第一次渲染之后 [修改流程:当组件的状态数据发生改变(setState)或者传递给组件的属性发生改变(重新调用组件传递不同的属性)都会引发 render 重新执行渲染(渲染也是差异渲染)] shouldComponentUpdate 是否允许组件重新渲染(允许则执行后面函数，不允许直接结束即可) componentWillUpdate 重新渲染之前 render 第二次及以后重新渲染 componentDidUpdate 重新渲染之后 componentWillReceiveProps 父组件把传递给子组件的属性发生改变后触发的钩子函数 [卸载:原有的渲染的内容是不消失的，只不过以后不能基于数据改变视图了] componentWillUnmount 卸载组件之前(一般不用)","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://lsw.name/tags/React/"}]},{"title":"React 的组件","slug":"react的组件","date":"2017-07-05T13:05:33.000Z","updated":"2018-07-11T14:45:48.391Z","comments":true,"path":"product-design//1499259933.html","link":"","permalink":"http://lsw.name/product-design/1499259933.html","excerpt":"","text":"ReactReact 组件 不管是 vue 还是 react 组件，设计之初都是期望我们按照”组件/模块管理”的方式来构建程序的，也就是把一个程序划分为一个个的组件来单独管理优势 有助于多人协作开发 我们开发的组件可以被复用 react 创建组件有两种方式; src-&gt;component这个文件件中存放的是开发组件 函数声明式文件 必须导入 react 模块(import),需要用到 JSX 的语法 函数返回的结果是一个新的 JSX(也就是当前组件的结构) props 变量存储的的值是一个对象，包含了调取组件时候传递的属性值,不传递的时候是一个空对象 基于继承 Component 类来创建组件 基于 createElement 把 JSX 转换为一个对象，当 render 渲染这个对象的时候，遇到 type 是一个函数或者类，不是直接创建元素，而是先把方法执行： 如果就是函数式声明的组件，就把它当做普通函数执行(方法中的 this 是 undefined)，把函数返回的 JSX 元素(也就是解析后的对象)进行渲染 如果是类声明式组件，会把当前类 new 执行，创建类的一个实例(当前本次调取的组件就是他的实例)，执行 constructor 之后，会执行 this.render(),把 render 中返回的 JSX 拿过来进行渲染，所以类声明式组件，必须有一个 render 的方法，方法中返回一个 JSX 元素 但是不管是那一种方式，最后都会把解析出来的 props 属性对象作为实参传递给对应的函数或者类 总结： 创建组件有两种方式 “函数式” “创建类式” [函数式] 写起来简单，操作简单 功能也是比较单一，只是简单的调取和返回 JSX 而已 [创建类式] 操作相对复杂一些，但是也可以实现更为复杂的业务功能 能够使用生命周期函数操作业务 函数式可以理解为静态组件(组件中的内容调取的时候就已经固定了，很难在修改)，而类这种方式，可以基于组件内部的状态来动态更新渲染的内容 组件的重要概念、开发的核心思想React 中的组件有两个非常重要的概念 组件的属性:[只读]调取组件的时候传递进来的信息 组件的状态:[读写]自己在组件中设定和规划的(只有类声明式组件才有状态的管控，函数组件声明不存在状态的管理) 组件状态类似于 VUE 中的数据驱动:我们数据绑定的时候是基于状态值绑定，当修改组件内部状态后，对应的 JSX 元素也会跟着重新渲染(差异渲染:只把数据改变的部分重新渲染，基于 DOM-DIFF 算法完成的) 当代前端框架最重要的核心思想就是:”数据操作视图(视图影响数据)”,告别 JQ 时代，我们以后只需要改变数据，框架会帮我们重新渲染视图，从而直接减少操作 DOM(提高性能，也有助于开发效率) 受控组件和非受控组件 真实项目中，建议大家多使用受控组件 基于数据驱动(修改状态数据，react 帮助我们重新渲染视图)完成的组件叫做”受控组件(受数据控制的组件)” 基于 ref 操作 DOM 实现视图更新的，叫做”非受控组件” 组件嵌套1.复合组件:父组件嵌套子组件 [传递信息的方式] 父组件需要把信息传递给子组件 [属性传递]：调取子组件的时候，把信息基于属性的方式传递给子组件(子组件 props 中存储传递的信息);这种方式只能父组件把信息传递给子组件，子组件无法直接的吧信息传递给父组件，也就是属性传递信息是单向传递的 &lt;section className=\"panel panel-default\"&gt; &lt;VoteHead title=&#123;title&#125; /&gt;&lt;/section&gt; [上下文传递父组件先把需要给后代元素(包括孙子元素)使用的信息都设置好(设置在上下文中)，后代组件需要用到父组件中的信息，主动去父组件中调取使用即可 harmony//父组件中 static childContextTypes=&#123; //设置上下文中的信息值的类型 n:PropTypes.number, m:PropTypes.number, &#125;; getChildContext()&#123; //return的是啥，相当于给上下文设置的是啥 return&#123; n:this.props.count.n, m:this.props.count.m, &#125; &#125;//子组件 static contextTypes=&#123; //首先类型需要和设置时候一样，用啥就写啥 n:PropTypes.number, m:PropTypes.number &#125;; 属性 VS 上下文 属性操作起来比较简单，子组件是被动接受传递的值 (组件内的属性是只读的，只能父传子，子传父或者父直接传孙都是不行的，父传孙需要处理，父传子，子传孙) 上下文操作起来相对比较复杂一些，子组件是主动获取信息的(子组件是可以修改获取到的上下文信息的，但是不会影响父组件中的信息，其他组件是不受影响的)，一旦父组件设置了上下文信息，他后代组件都可以直接拿来使用不需要一层层的传递; 子组件修改父组件中的信息 利用回调函数的机制：父组件把一个函数通过属性或者上下文的方式，传递给子组件，子组件只要把这个方法执行即可(也就是子组件中执行父组件中的方法，还可以传递一些值过去)，这样父组件在这个方法中，想把自己的信息改成啥就改成啥 平行组件:兄弟组件或者毫无关系的两个组件 让二个平行组件拥一个共同的父组件 父： parent 子： A/B 父组件中有一些信息，父组件把一个方法传递给 A，A 中把方法执行(方法执行修改父组件信息值)，父组件再把最新的信息传递给 B 即可，等价于 A 操作，影响了 B 基于 redux 来进行状态管理，实现组件之间的信息传输(常用方案) redux 可以应用在任何的项目中(vue/jq/react 的都可以)，react-redux 才是 react 项目专用的方案","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://lsw.name/tags/React/"}]},{"title":"React 的 MVC 模式、脚手架以及把 JSX 渲染为真实的 DOM 原理","slug":"react的MVC模式、脚手架以及把JSX渲染为真实的DOM原理","date":"2017-07-01T14:14:28.000Z","updated":"2018-07-11T14:56:52.009Z","comments":true,"path":"product-design//1498918468.html","link":"","permalink":"http://lsw.name/product-design/1498918468.html","excerpt":"","text":"React简述 MVC 框架 MVC 是一种使用 MVC(Model View Controller 模型-视图-控制器)设计创建 Web 应用程序的模式 Model(模型)可以简单的理解为数据层，用于提供数据。对数据库的操作这一些的代码作为 model 层， View(视图)是应用程序中处理数据显示的部分，通常视图是依据模型数据创建的，一般所有的 JSP、HTMl 等页面就是 View 层 Controller(控制器)功能就是将 Model 和 View 层进行关联，比如 View 主要是显示数据的，但是数据又需要 Model 去访问，这样的话，View 会先告诉 Controller，然后 Controller 再告诉 Model，Model 请求完数据之后，再告诉 View。这样 View 就可以显示数据了 React 脚手架 前端的工程化开发 划分组件开发 基于路由的 SPA 单页面开发 一般都是基于 ES6 来编写代码(最后部署上线的时候，我们需要把 ES6 编译为 ES5=&gt;基于 babel 来完成编译) 可能用到 Less/Sass 等，我们也需要对应的插件把他们进行预编译 最后为了优化性能，减少 http 请求的次数，我们需要把 js/css 进行合并压缩 webpack 来完成以上页面组件合并、js/css 编译加合并等工作 创建脚手架 安装create-react-app npm install create-react-app -g 基于create-react-app [项目名称]脚手架的命令，创建一个基于 react 的自动化/工程化项目目录，项目名称中不能出现大写字母、中文汉字，特殊符号(-或者_是可以)等 脚手架生成目录中的一些内容 node_modules 当前项目中依赖的包都安装在这里(.bin 本地项目中可执行的命令，在 package.json 的 scripts 中配置对应的脚本命令) public 存放的是当前项目的 HTML 页面(单页面应用放一个 index.html 即可，多页面根据自己需求放置需要的页面) src 项目结构中主要的目录，因为后期所有的 JS、路由、组件都是放到这里面(包括需要编写的 css 或者图片等)，index.js 是当前项目的主入口文件 .gitignoregit 提交时候，忽略提交文件的配置项 package.json 当前项目的配置清单,基于脚手架生成工程目录，自动帮我们安装了三个模块:react/react-dom/react-scripts,react-scripts 集成了 webpack 需要的内容(编译包：babel 一套，css 处理的一套，eslint 一套，webpack 一套，其他的，没有 less/sass 的处理内容，项目中若是使用 less，我们需要自己额外的安装) //package.json&#123; \"dependencies\": &#123; \"react\": \"^16.4.1\", \"react-dom\": \"^16.4.1\", \"react-scripts\": \"1.1.4\" &#125;, \"scripts\": &#123; \"start\": \"react-scripts start\" /*开发环镜下，基于webpack编译处理，最后可以预览当前开发的项目成果(在webpack中安装了webpack-dev-server插件，基于这个插件会自动创建一个web服务[端口号默认是3000]，webpack会默认打开浏览器，并展示我们的页面，并且能够监听我们代码的改变，如果代码改变，webpack会自动重新编译，并且刷新浏览器完成重新渲染)*/, \"build\": \"react-scripts build\" /*项目需要部署到服务器上，我们先执行yarn build，把项目整体编译打包 (完成后会在项目中生成一个build文件夹，这个文件夹中包含了所有编译后的内容，我们把它上传到服务器即可),而且在服务上进行部署的时候，不需要安装任意的模块*/, \"test\": \"react-scripts test --env=jsdom\", \"eject\": \"react-scripts eject\" &#125;&#125; public 中路径的问题&lt;link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\"&gt;&lt;link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\"&gt; 在 react 当中，所有的逻辑都是在 jS 中完成的(包括页面结构的创建)，如果想给当前页面导入一些 css 样式或者 img 图片等内容，我们有两种方式， 第一种在 JS 中基于 es6 module 模块规范，使用 import 导入，这样 webpack 在编译合并 JS 的时候，会把导入的资源文件等插入到页面的结构中(绝对不能在 js 管控的结构中通过相对目录./或者../,导入资源) ，因为 webpack 编译的时候，地址就不在是 之前的相对路径 第二种，如果不想在 js 中导入(JS 中导入的资源最后都会基于 webpack 编译，我们也可以把资源手动的在 HTML 中导入，但是 HTML 最后 也要基于 webpack 编译，导入的地址也不建议写相对地址，而是使用%public_URL%写成绝对地址) 脚手架的深入 create-react-app 脚手架为了结构目录清晰，把安装的 webpack 及配置文件都集成在了 react-scripts 模块上，放到了 node_modules 中 真实项目中，我们需要在脚手架默认安装的基础上，额外安装一些我们需要的模块，例如：react-router-dom/axios/…,再比如 less/less-loader… 情况一：如果我们安装其他的组件，但是安装成功后不需要修改 webpack 的配置项，此时我们直接安装，并且调取使用即可 情况二：我们安装的插件是基于 webpack 处理的，也就是需要把安装的模块配置到 webpack 中，需要重新修改 webpack 配置项了： 首先需要把隐藏到 node_modules 的配置项暴露到项目中yarn eject,首先会提示确认是否执行 eject 操作，这个操作是不可逆的，一旦暴露出来配置项，就无法隐藏回去了，如果当前的项目基于 git 管理，会报错，提醒你提交到历史区 再去修改对应的配置项即可，一旦暴露后，项目目录中多了两个文件夹：config 存放的是 webpack 的配置文件(webpack.config.dev.js 开发环镜下的配置项-yarn start，webpack.config.prod.js 生产环镜下的配置项-yarn build)，scripts 存放的是可执行脚本的 js 文件(start.js/build.js/test.js=&gt;yarn xxx 对应) package.json 也改变了， 例如 less less 是开发和生产环镜下都需要配置的 我们预览项目的时候，也是基于 webpack 编译，把编译后的内容放到浏览中运行，所以如果项目中使用了 less，我们需要修改 webpack 配置项，在配置项中放入 less 的编译工作，这样后期预览项目，首先基于 webpack 编译成 css，再呈放到页面中 环镜变量的修改、协议、端口号 set HTTPS=true&amp;&amp;yarn start 开启 HTTPS 协议 设置环镜变量 HTTPS 的值 set PORT=63341&amp;&amp;yarn start 修改端口 react&amp;&amp;react-dom [渐进式框架] 目前最流行的框架设计思想，一般框架中包含很多内容，这样导致框架的体积过于臃肿，不利于页面的优化，真实项目中，我们使用一个框架，不一定用到所有的功能，此时我们应该把框架的功能拆分，用户想用什么，让其自己自由组合即可 [全家桶] 渐进式框架 N 多部分的组合 vue 全家桶:vue-cli/vue/vue-router/vuex/axios(fetch)/vue element(vant) react 全家桶:creatr-react-app/react/react-dom/react-router/redux/react-redux/axios/ant/dva/saga/mobx react:react 框架的核心部分，提供了 Component 类可以供我们进行组件开发，提供了钩子函数(生命周期函数:所有的生命周期函数都是基于回调函数完成的)react-dom:把 jsx 语法(react 独有的语法)渲染为真实的 DOM(能够放到页面中展示的结构都叫做真实的 DOM)的组件 把 JSX(虚拟 DOM)变为真实的 DOM//导入组件import React from 'react';import ReactDOM from 'react-dom';//语法ReactDOM.render([jsx],[container],[callback]);把jsx元素渲染到页面中 jsx：react虚拟元素 container容器，我们想把元素放到页面中的哪个容器中 callback：当把内容放到页面中呈现触发的回调函数 JSX：react 独有的语法 javascript+XML(HTML) 和我们之前自己拼接的 HTML 字符串类似，都是把 HTML 结构代码和 JS 代码或者数据混合在一起了，但是他不是字符串 在写 render 的时候的规范 1.不建议我们把 jsx 直接渲染到 body 中，而是放在自己创建一个容器中，一般我们都放在一个 ID 为 root 的 DIV 中即可*/ 2.在 JSX 中出现的{}是存放 js 的，但是要求 js 代码执行完成需要有返回结果(JS 表达式) - 不能直接放一个对象数据类型的值(对象(除了给style赋值)、数组(数组中没有对象都是基本值或者是JSX元素，这样是可以的)、函数都不行) - 可以是基本类型的值(布尔类型的值什么都不显示，但是不会报错，null、undefined也是JSX元素，代表是空) - 循环判断的语句 都不支持，但是支持三元运算符 3.循环数组创建 JSX 元素(一般都是基于数组的 MAP 方法完成迭代)，需要给创建的元素设置唯一的 key 值(当前本次循环内唯一即可) 4.只能出现一个根元素 5.给元素设置样式类用的是 className 不是 class6.style 中不能直接写样式字符串，需要基于一个样式对象来遍历赋值jsx 渲染机制 1.基于 babel 中的语法解析模块(babel-preset-react)把 jsx 语法编译为 React.createElement(…)的结构 2.执行 React.createElement(type,props,children)函数，会创建一个对象(虚拟 DOM)3.ReactDOM.render(JSX 语法最后生成的对象，容器，回调函数)，基于 Render 方法把生成的对象动态创建为 DOM 元素，插入到指定的容器中 JS 原理 //参数至少两个，type/props children这个部分可能没有可能有多个function createElement(type, props, ...childrens) &#123; //返回一个对象，创建一个对象，默认有四个属性(type,props,ref,key) //根据传递的值修改这个对象 /* * type 传递的type的值 * props 需要做一些处理:大部分传递的props属性都赋值给对象的props，有一些比较特殊 如果是ref或者key，我们需要把传递的props的这两个属性值删除掉 * 把传递的children作为新创建对象的props中的一个属性*/ props = props || &#123;&#125;; let obj = &#123; type: \"null\", props: &#123; children: \"\" &#125;, ref: null, key: null &#125;; //obj=&#123;...obj,type,props&#125;;//=&gt;&#123;type:type,props:props&#125;用传递的type和props覆盖原有的默认值 obj = &#123; ...obj, type, props: &#123; ...props, children: childrens.length &lt;= 1 ? childrens[0] || \"\" : childrens &#125; &#125;; //=&gt;把ref和key都提取出来,并且删除props中的属性 \"key\" in obj.props ? ((obj.key = obj.props.key), delete obj.props.key) : null; \"ref\" in obj.props ? ((obj.ref = obj.props.ref), (obj.props.ref = undefined)) : null; return obj;&#125;/*Render把创建的元素生成对象的DOM元素，最后插入到页面中*/function render(obj, container, callback) &#123; let &#123; type, props &#125; = obj || &#123;&#125;, newElement = document.createElement(type); for (let attr in props) &#123; if (!props.hasOwnProperty(attr)) break; //结束遍历 if (!props[attr]) continue; //继续下一个 let value = props[attr]; if (attr === \"className\") &#123; newElement.setAttribute(\"class\", value); continue; &#125; if (attr === \"style\") &#123; if (value === \"\") continue; for (let styKey in value) &#123; if (value.hasOwnProperty(styKey)) &#123; newElement.style[styKey] = value[styKey]; &#125; &#125; continue; &#125; if (attr === \"children\") &#123; /*可能是一个值:是字符串成也可能是JSX对象 或者数组 数组中的每一项可能是字符串也可能是JSX对象*/ if (!(value instanceof Array)) &#123; value = [value]; //统一变成数组方便操作 &#125; value.forEach((item, index) =&gt; &#123; //验证item是什么类型的 字符串就是创建文本节点，是对象，再次执行render方法，把创建的元素放到做开始的大盒子中 if (typeof item === \"string\") &#123; let text = document.createTextNode(item); newElement.appendChild(text); &#125; else &#123; render(item, newElement); &#125; &#125;); continue; &#125; newElement.setAttribute(attr, value); //基于setAttribute可以使设置的属性表现在HTML上 &#125; container.appendChild(newElement); callback &amp;&amp; callback();&#125;//方法的使用let obj = createElement( \"div\", &#123; id: \"box\", className: \"box\", style: &#123; color: \"red\" &#125; &#125;, createElement(\"h2\", &#123; className: \"title\" &#125;, \"\\u7CFB\\u7EDF\\u63D0\\u793A\"), createElement( \"div\", &#123; className: \"content\" &#125;, \"\\u6E29\\u99A8\\u63D0\\u793A\\uFF1A\\u8BED\\u6CD5\\u9519\\u8BEF\\uFF01\" ), \"\\u672C\\u64CD\\u4F5C\\u5C31\\u662F\\u4E00\\u4E2A\\u6D4B\\u8BD5\\uFF01\");render(obj, root, () =&gt; &#123; console.log(\"ok\");&#125;);","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://lsw.name/tags/React/"}]},{"title":"Vue 的 MVVM 和双向数据绑定","slug":"vue","date":"2017-05-10T13:05:33.000Z","updated":"2018-07-11T14:35:59.575Z","comments":true,"path":"product-design//1494421533.html","link":"","permalink":"http://lsw.name/product-design/1494421533.html","excerpt":"","text":"Vue介绍 MVVM 框架 MVVM 是 model-View-ViewModel 的简写，本质上就是 MVC 的改进版，MVVM 就是将其中的 View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。 ## 双向数据绑定的原理以及传入的参数 在 vue 中,可以引入一个 vue.js，通过创建 vue 的实例来初始化 &lt;div id=\"app\"&gt; &#123;&#123;name&#125;&#125; &lt;input type=\"checkbox\" v-model=\"value\"&gt;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123; el:'#app',//元素ID或类名 data:&#123;//初始化数据=&gt;数据必须声明后才能使用, name:'Hello' , value:false &#125;, methods:&#123;//绑定事件,方法写在这&#125;, mounted()&#123;&#125;,//页面初始化完成，获取元素可以在这里面写 filters:&#123;//过滤器 toFixed(target,n)&#123;//target,n 默认是传的参数 n是手动传的参数 return target //必须有返回值 函数的返回值是字符串 &#125; &#125;, computed:&#123;//计算属性，在这里写的数据不能在data中声明 ss:&#123; get()&#123;&#125;,//必须写返回值，否则得不到值，第一次获取的时候，依赖值没有发生改变但是也会默认执行一次 set()&#123;&#125; &#125; &#125;, watch:&#123;//watch监控的属性是data中的属性，监控的都是直接的属性 val:&#123;//属性里面的属性值都是固定的 handler(newVal,oldVal)&#123;//(新值，旧值) &#125;, immediate:true,//，默认第一次不执行，加上这个属性，第一次执行一下，旧值为undefined deep:true//深度检测，可以检测对象的具体属性的改变 &#125; &#125;&#125;);vm.name='hello';vm.$set(vm.obj,name,'world');&lt;!--vue中如果是改变数组中的某一项，推荐数组重新赋值--&gt;&lt;/script&gt; 利用 JS 模拟双向数据绑定 原理是 OBject.defineProperties() &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"value\"&gt;&lt;/div&gt;&lt;script&gt; let app = document.querySelector('#app'), input = app.querySelector('input'); let data=&#123;value:''&#125;; input.onchange=function() &#123; data[this.getAttribute('v-model')]=this.innerHTML; &#125;; Object.defineProperties(data,&#123; value:&#123; set(val)&#123; input.inner=val; &#125; get()&#123; return ''//返回的什么值就是什么 &#125; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://lsw.name/tags/Vue/"}]}]}