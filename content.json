{"meta":{"title":"文艺青年","subtitle":"关注技术和人文的原创IT博客","description":"前端，博客，个人博客","author":"刘某某","url":"http://lsw.name"},"pages":[{"title":"为何建站 && 为何写作","date":"2017-02-07T05:23:07.000Z","updated":"2018-06-26T08:12:33.376Z","comments":false,"path":"about/index.html","permalink":"http://lsw.name/about/index.html","excerpt":"","text":"为何建站在我年轻的时候，独立站长曾是一个牛逼闪闪的角色，然而现在不那么神秘了。搭建说IT这个网站主要是为了记录技术成长的点滴，当然装逼也是一个目的。 为何写写作 读的书越多，你会发现知道的东西越多，不知道的东西就更多了，不知道远远大于知道，于是你在两者间不断碰撞、焦虑、欢喜、忧伤，产生各种思想、情感和故事，记录下来，就是文章。 引自《MacTalk》跨越边界 显然，写作是个艺术活儿，这个博客是带有某种程序员感情的，如果你是这种艺术家，那就能共震了！ 本站主要作为技术笔记存档，内容主要涉及前端开发（含移动端），偶尔可能也会有一些碎碎念、开开车。如果某一篇帮助了你，请记得点个赞。 作为内容站，持续输出高质量的内容是件不太容易的事情，本站的任何文章，你可任意转载，但请保留原文链接。如有兴趣，欢迎一起码字。 关于作者斜杠中年、文字控、周杰伦迷，就职于粗粮厂的90后程序猿。目前致力于JavaScript大法，ReactNative是目前的工作。鸡汤一站，请自取一篇饮 如果您遇到麻烦或对本站有疑问，请在本站找到那个白色❓号并点击查看 没时间再解释了，赶紧上车…"},{"title":"移动互联网？","date":"2017-03-18T11:56:20.000Z","updated":"2018-06-26T15:39:02.575Z","comments":false,"path":"app/index.html","permalink":"http://lsw.name/app/index.html","excerpt":"","text":"憋闹了，还没App。网页写的差不多了，再考虑写移动互联网….public static void main(String args[]) throws Exception &#123; for (int i = 0; ; i++) &#123; Thread.sleep(1000); System.out.println(\"嗯、写码，呵呵...\" + i); &#125;&#125; fyiguhjnwkefnmwoeih68yuih4jnkrfewdfyugbijnk.wfww3f 5jhyrtgve5jhytbgvef5grefvqwu6ejynhbvwer5jr5hb4gevgwh54uh3g4weab eh43eg223t4whretbvfw345u36jhtbevww32q4wu5ejhtbevwgw354uhtbgevfcewg 擦了下键盘，这些你可以拿去当QQ密码，绝不会被盗号，不用谢！"},{"title":"QA - 帮助那个中心...","date":"2017-03-29T10:49:38.000Z","updated":"2018-06-26T15:39:51.509Z","comments":true,"path":"help/index.html","permalink":"http://lsw.name/help/index.html","excerpt":"","text":"这里不发表情，准备说点严肃、实在的…Q: 这网站怎么弄的，还挺好看的啊？ A: 本站是静态博客，通过hexo生成，主题是我自己写的。免费使用，已开源至GitHub，本站底部有它们的链接 Q: 为什么博客有时候打开速度很慢，一直在加载呢？ A: 评论组件使用的Disqus等资源的服务器在墙外，你懂的…(不懂问搜狗)。不过不影响文章阅读。 Q: 我也想用这个主题搭个博客，不知道怎么弄？ A: 先去hexo官网看看，学会用这个写作并学会使用gitpages之类的部署博客。教程谷歌一下遍地皆是。主题是免费的，在本站底部可找到链接，根据文档自及配置就好了。遇到问题，在本页留言即可，我会很愿意帮助你的。需要注意的是主题有全站https开关，在主题_config.yml文件的fullHttps处配置。如配置不当r某些文件就无法正确引用，加载粗来的页面会很挫。 Q: 你这主题，我配置了怎么运行报错啊，跑不起来啊？ A: 关于使用主题出错，请先前往JSimple-issues寻找答案，说不定你遇到的问题，已经有人碰到而我也回答解决方式了。关于主题的任何问题，我都会在那里回复 Q: 无法自由翱翔互联网咋办？ A: 着急吃饭且自甘有钱的朋友请直接购买蓝灯。不着急就慢慢找吧，像GreenVPN、www.ishadowsocks.com都是很好的方案。另外有hosts方案，请前往这个项目UsefullShells Q: 如何找到一个靠谱的对象？ 如果你有资源，记得第一时间告诉我… Q: 我觉得站长你挺有意思的，能交个朋友吗？ A: 可以，来握个手吧：斜杠中年 暂时更新这些，需要什么本文底部留言……"},{"title":"嘉宾推荐","date":"2017-02-07T05:22:22.000Z","updated":"2018-06-26T15:40:22.628Z","comments":false,"path":"links/index.html","permalink":"http://lsw.name/links/index.html","excerpt":"","text":"以下摘录有趣、有意义、有影响力、有正能量的博客、资源 此处不做网址导航，因此不接受以SEO为目的的友链。排序不分那啥… JS大法系 阮一峰博客闲情写手腾讯AlloyTeam 苹果派 王巍（喵神）的博客Objc.ioSwifter 娱乐圈 VIMCodeTank 公众号 没有链接，请直接关注微信公众号：涔汐(zhangcenxi99)、小道消息、MacTalk等等"},{"title":"标签云","date":"2017-02-04T07:37:12.000Z","updated":"2018-06-26T15:40:40.790Z","comments":true,"path":"tags/index.html","permalink":"http://lsw.name/tags/index.html","excerpt":"","text":""},{"title":"时光轴","date":"2017-02-07T05:23:27.000Z","updated":"2018-06-26T15:41:00.720Z","comments":false,"path":"timeline/index.html","permalink":"http://lsw.name/timeline/index.html","excerpt":"","text":"时光轴嘛，得先有时光，会更新的，别急……"}],"posts":[{"title":"Promise 原理","slug":"promise原理","date":"2017-06-10T13:18:28.000Z","updated":"2018-07-11T14:47:09.337Z","comments":true,"path":"front-end//1497100708.html","link":"","permalink":"http://lsw.name/front-end/1497100708.html","excerpt":"","text":"Promiseclass Promise &#123; constructor(fn) &#123; this.value = undefined; this.state = \"pending\"; this.resolveAry = []; this.rejectAry = []; let resolveFn = res =&gt; &#123; let timer = setTimeout(() =&gt; &#123; clearTimeout(timer); if (this.state === \"pending\") return; this.state = \"success\"; this.resolveAry.forEach(item =&gt; &#123; item(this.value); &#125;); &#125;); &#125;; let rejectFn = err =&gt; &#123; let timer = setTimeout(() =&gt; &#123; clearTimeout(timer); if (this.state === \"pending\") return; this.state = \"failed\"; this.rejectAry.forEach(item =&gt; &#123; item(this.value); &#125;); &#125;); &#125;; fn(resolveFn, rejectFn); &#125; then(resolveCallback, rejectCallback) &#123; typeof resolveCallback !== \"function\" ? (resolveCallback = res =&gt; res) : null; typeof rejectCallback !== \"function\" ? (rejectCallback = err =&gt; &#123; throw new Error(err instanceof \"Error\" ? err.message : err); &#125;) : null; return new Promise((resolve, reject) =&gt; &#123; this.resolveAry.push(() =&gt; &#123; try &#123; let x = resolveCallback(this.value); x instanceof Promise ? Promise.then(resolve, reject) : resolve(x); &#125; catch (e) &#123; reject(e); &#125; &#125;); this.rejectAry.push(() =&gt; &#123; try &#123; let x = rejectCallback(this.value); x instanceof Promise ? Promise.then(resolve, reject) : resolve(x); &#125; catch (e) &#123; reject(e); &#125; &#125;); &#125;); &#125; catch(reject) &#123; this.then(null, reject); &#125; static all(promiseAry = []) &#123; let index = 0, result = []; return new Promise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promiseAry.length; i++) &#123; promiseAry[i].then(res =&gt; &#123; index++; result[i] = res; if (index === promiseAry.length) &#123; resolve(result); &#125; &#125;, reject); &#125; &#125;); &#125;&#125;","categories":[{"name":"前端","slug":"front-end","permalink":"http://lsw.name/categories/front-end/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"}]},{"title":"React-Redux","slug":"react-redux","date":"2017-06-10T13:18:28.000Z","updated":"2018-07-11T14:34:48.358Z","comments":true,"path":"product-design//1497100708.html","link":"","permalink":"http://lsw.name/product-design/1497100708.html","excerpt":"","text":"react-reduxredux :进行一种统一管理的类库(适用于任何技术体系的项目) 只要两个或者多个组件之间想要实现信息的共享，都可以基于 redux 解决，把共享的信息存储到 redux 容器中进行管理=&gt;购物车的案例 还可以使用 redux 做临时存储:页面加载的时候，把从服务器获取的数据信息存储到 redux 中，组件渲染需要的数据，从 redux 中获取，这样只要页面不刷新，路由切换的时候，再次渲染组件不需要重新服务器拉取数据，直接从 redux 中获取即可；页面刷新，从头开始(优化 性能，localStorage 也可以，这套方案可以代替本地存储 原理 /** * 创建建redux容器的 * @param reducer 函数 * @return * store&#123; * getState, * dispatch, * subscribe * &#125; */function createStore(reducer) &#123; //创建一个store=&gt;state用来存储的状态信息，listenAry用来存储事件池中的方法 //state不用设置初始值，因为第一次dispatch，state没有值，走的是reducer中赋值的默认值信息，我们自己会在创建容器的时候就把dispatch执行一次 let state, listenAry = []; //基于dispatch实现任务派发 function dispatch(action) &#123; //1.执行reducer，修改容器中的状态，把reducer的返回值替换原有的state,值得注意的是，我们把返回值全部替换state，所有要求reducer中在修改状态之前，要先把原始的状态信息克隆一份，在进行单个的属性修改 state = reducer(state, action); //2.通知事件池中的方法执行 for (let i = 0; i &lt; listenAry.length; i++) &#123; let item = listenAry[i]; if (typeof item === \"function\") &#123; item(); &#125; else &#123; listenAry.splice(i, 1); i--; &#125; &#125; &#125; dispatch(&#123; type: \"_INIT_DEFAULT_STATE\" &#125;); //创建容器的时候执行一次dispatch，目的是把reducer中的默认初始状态信息赋值给redux容器中的状态 //获取容器中的最新信息 function getState() &#123; //我们需要保证返回的状态信息不能和容器中的state是同一个堆内存(否则外面获取状态信息后，直接可以修改容器中的状态了，这不符合dispatch-&gt;reducer才能改状态的规范) //[浅克隆] &#123;...state&#125; 如果属性值中还有对象类型，则克隆的是地址 //[深克隆] JSON.parse(JSON.stringify(state)) return JSON.parse(JSON.stringify(state)); //深度克隆对象 &#125; //事件池追加方法 function subscribe(fn) &#123; //向容器中追加方法(去重处理) let isExist = listenAry.includes(fn); !isExist ? listenAry.push(fn) : null; //返回一个方法：执行返回的方法会把当前绑定的方法在事件池中移除掉 return function unsubscribe() &#123; let index = listenAry.indexOf(fn); //listenAry.splice(index,1);可能会引发数组坍陷 listenAry[index] = null; &#125;; &#125; return &#123; dispatch, getState, subscribe &#125;;&#125;let reducer = (state = &#123;&#125;, action) =&gt; &#123; //state原有的状态信息 action是dispatch派发任务时候传递的行为对象 let &#123; type &#125; = action; switch ( type //... 通过type的不同修改state信息，执行不同的修改操作 ) &#123; &#125; //将最新的state返回替换原有的 return state;&#125;;// //用法// let store = createStore(reducer);//create的时候把reducer传递进来，但是此时reducer并没有执行呢，只有 dispatch的时候才执行，通过执行reducer修改容器中的状态// store.dispatch(&#123;type: ''&#125;);//// let ary = [1, 2, 3, null];// ary.forEach((item, index) =&gt; &#123;// item === null ? ary.splice(index, 0) : null//// &#125;);/** * @PARAMS 对象，对象中包含每一个版块对象的reducer=&gt;&#123;xxx:function reducer()&#123;&#125;&#125; * @RETURN 返回的是一个新的reducer函数(把这个值赋值给create-store) * 特殊处理: 合并reducer之后，redux容器中的state也变为以对应对象管理的模式=&gt;&#123;xxx:function()&#123;&#125;&#125; */function combineReducers(reducers) &#123; //reducers:传递进来的reducer对象集合 /* * &#123; * custom:function reducer ()&#123;&#125; * &#125; * */ return function reducer(state = &#123;&#125;, action) &#123; //DISPATCH派发执行的时候，执行的是返回的reducer，这里也要返回一个最终的state对象替换原有的state，而且这个state中需要包含每个模块的状态信息=&gt;&#123;custom:...,personal:....&#125; //我们所谓的reducer合并，其实就是dispatch派发的时候，把每一个模块reducer都单独执行一遍，把每个模块返回的状态最后汇总在一起，替换容器中的状态信息 let newState = &#123;&#125;; for (let key in reducers) &#123; if (!reducers.hasOwnProperty(key)) break; //reducers[key]每个模块单独的reducer //state[key]当前模块在redux容器中存储的状态信息 //返回值是当前模块最新的状态，把它在放到newState中 newState[key] = reducers[key](state[key], action); &#125; return newState; &#125;;&#125; react-reduximport React from \"react\";import PropTypes from \"prop-types\";import action from \"../store/action\";/** * 'PROVIDER' 当前项目的根组件 * 1.接受通过属性传递进来的store，把store挂载到上下文中，这样当前项目中任何一个组件中，想要redux中的store，直接通过上下文获取即可 * 2.在组件的render中把传递给provider的子元素渲染 */class Provider extends React.Component &#123; //设置上下文信息类型 static childContextTypes = &#123; store: PropTypes.object &#125;; //设置上下文信息值 getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; constructor(props, context) &#123; super(props, context); &#125; render() &#123; return this.props.children; &#125;&#125;/** * connect 高阶组件(基于高阶函数:柯理化函数)创建的组件就是高阶组件 * @PARAMS * - mapStateToProps回调函数 把redux中的部分状态信息(方法返回的内容)挂载到指定组件的属性上 * - mapDispatchToProps回调函数 把一些需要派发的任务方法也挂载到组件的属性上 * @RETURN * 返回一个新的函数 * @PARAMS connect-hot()传递要操作的组件，我们需要把指定的属性和方法都挂载到当前组件属性和方法上 * @RETURN 返回一个新的组件Proxy(代理组件)，在代理组件中，我们要获取Provider在上下文中存储的store，紧接着获取store中的state和dispatch，把mapStateToProps、mapDispatchToProps回调函数执行，接受返回的结果，在把这些结果挂载到Component这个要操作的组件 */let mapStateToProps = state =&gt; &#123; //state是redux荣全国中的状态信息 return &#123; /*return对象中有啥，就把啥挂载到属性*/ &#125;;&#125;;let mapDispatchToProps = dispatch =&gt; &#123; //dispatch:store中的dispatch return &#123; /*有哪些方法就挂载到属性上,返回的方法中有执行dispatch派发任务的操作*/ &#125;;&#125;;function connect(mapStateToProps, mapDispatchToProps) &#123; return function connectHOT(Component) &#123; return class Proxy extends React.Component &#123; //获取上下文中的store static contextTypes = &#123; store: PropTypes.object &#125;; //获取store中的state和dispatch，把传递的两个回调函数执行，接受返回的结果 constructor(props, context) &#123; super(props, context); this.state = this.queryMountProps(); &#125; //基于redux中的subscribe向事件池中追加一个方法，当容器中状态改变，我们需要重新获取最新的状态信息，并且重新把component渲染，把最新的状态信息通过属性属性传递给component componentDidMount() &#123; this.context.store.subscribe(() =&gt; &#123; this.setState(this.queryMountProps()); &#125;); &#125; //渲染component组件，并且把获取的信息(状态、方法)挂载到组件属性上 render() &#123; /*&#123;...this.state&#125;这里的括号给js运行环镜*/ return &lt;Component &#123;...this.state&#125; /&gt;; &#125; //从redux中获取最新的信息，基于回调函数筛选，返回的是需要挂载到组件属性上的信息 queryMountProps = () =&gt; &#123; let &#123; store &#125; = this.context, state = store.getState(); let propsState = typeof mapStateToProps === \"function\" ? mapStateToProps(state) : &#123;&#125;; let propsDispatch = typeof mapDispatchToProps === \"function\" ? mapDispatchToProps(store.dispatch) : &#123;&#125;; return &#123; ...propsState, ...propsDispatch &#125;; &#125;; &#125;; &#125;;&#125;//export default connect(state=&gt;(&#123;...state.custom&#125;),action.custom)(VoteBase); 得到的结果是Proxy中嵌套了一个Component，不是只返回了一个Componentexport &#123; Provider, connect &#125;; redux 中间件 redux-logger 能够在控制台，清晰的展示出当前 redux 操作的流程和信息(原有状态、派发信息、修改后的状态信息) redux-thunk 处理异步的 dispatch 派发 redux-promise 在 dispatch 派发的时候支持 promise 操作","categories":[{"name":"框架","slug":"product-design","permalink":"http://lsw.name/categories/product-design/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://lsw.name/tags/JavaScript/"},{"name":"React","slug":"React","permalink":"http://lsw.name/tags/React/"}]}]}